[
    {
        "instance_id": "bq011",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "How many pseudo users were active in the last 7 days but inactive in the last 2 days as of January 7, 2021?",
        "external_knowledge": "ga4_obfuscated_sample_ecommerce.events.md",
        "plan": "1. Identify pseudo users (`user_pseudo_id`) active in the last 7 days: query the `events_*` tables to find users who were active in the last 7 days based on engagement time and filter them by the fixed timestamp and relevant table suffixes (from `20210101` to `20210107`).\n2. Identify pseudo users (`user_pseudo_id`) active in the last 2 days: query the `events_*` tables to find users who were active in the last 2 days based on engagement time and filter them by the fixed timestamp and relevant table suffixes (from `20210105` to `20210107`).\n3. Combine results and filter:\n- Use a `LEFT JOIN` to combine the two sets of users and filter out users who were active in the last 2 days.\n- Count the distinct user IDs who meet the criteria of being active in the last 7 days but not in the last 2 days.",
        "special_function": [
            "timestamp-functions/TIMESTAMP",
            "timestamp-functions/TIMESTAMP_SUB",
            "timestamp-functions/UNIX_MICROS",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq010",
        "db": "bigquery-public-data.google_analytics_sample",
        "question": "Find the top-selling product among customers who bought 'Youtube Men\u2019s Vintage Henley' in July 2017, excluding itself.",
        "external_knowledge": "google_analytics_sample.ga_sessions.md",
        "plan": "1. Extract a distinct list of customers (`fullVisitorId`) who purchased the \"YouTube Men's Vintage Henley\" in July 2017.\n2. Find other products purchased by these customers in July 2017.\n3. Filter out the \"YouTube Men's Vintage Henley\" product itself and aggregate other products purchased by the same customers.\n4. Sort to find the most purchased product.",
        "special_function": [
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq009",
        "db": "bigquery-public-data.google_analytics_sample",
        "question": "Which traffic source receives the top revenue in 2017 and what is the difference (millions, rounded to two decimal places) between its highest and lowest revenue months?",
        "external_knowledge": "google_analytics_sample.ga_sessions.md",
        "plan": "1. Calculate monthly revenue for each traffic source.\n2. Aggregate the monthly revenues to compute the total yearly revenue for each traffic source.\n3. Determine which traffic source has the highest total revenue for the year 2017.\n4. Retrieve the monthly revenue data for the top traffic source identified in the previous step.\n5. Calculate the difference between the highest and lowest monthly revenues for the top traffic source.\n6. Retrieve the traffic source and the revenue difference.",
        "special_function": [
            "date-functions/DATE",
            "date-functions/FORMAT_DATE",
            "date-functions/PARSE_DATE",
            "mathematical-functions/ROUND"
        ]
    },
    {
        "instance_id": "bq001",
        "db": "bigquery-public-data.google_analytics_sample",
        "question": "I wonder how many days between the first transaction and the first visit for each transacting visitor in Feburary 2017, along with the device used in the transaction.",
        "external_knowledge": "google_analytics_sample.ga_sessions.md",
        "plan": "1. Firstly, extract the first visit date for each visitor in the specified range `201702`.\n2. Next, extract the first transaction date for each visitor in Feb 2017.\n3. Then, extract the device categories used for transactions.\n4. Combine the visit, transaction and device data.\n5. Calculate the number of days between the first transaction and the first visit date for each visitor using `DATE_DIFF`.",
        "special_function": [
            "date-functions/DATE",
            "date-functions/DATE_DIFF",
            "date-functions/PARSE_DATE",
            "json-functions/STRING",
            "time-functions/TIME",
            "timestamp-functions/STRING",
            "other-functions/DECLARE",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq002",
        "db": "bigquery-public-data.google_analytics_sample",
        "question": "What's the maximum monthly, weekly, and daily product revenues (in millions) generated by the top-performing traffic source in the first half of 2017?",
        "external_knowledge": "google_analytics_sample.ga_sessions.md",
        "plan": "1. Firstly, we define the date range to be the first half of year 2017: 20170101 to 20170630.\n2. Next, calculate daily revenues for each traffic source.\n3. Similarly, calculate weekly and monthly revenues for each traffic source.\n4. Determine the top-performing traffic source through aggregation and sorting.\n5. Calculate the maximum revenues for this traffic source on daily/weekly/monthly basis respectively.\n6. Return the final results.",
        "special_function": [
            "date-functions/DATE",
            "date-functions/EXTRACT",
            "date-functions/PARSE_DATE",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "json-functions/STRING",
            "string-functions/CONCAT",
            "time-functions/EXTRACT",
            "time-functions/TIME",
            "timestamp-functions/EXTRACT",
            "timestamp-functions/STRING",
            "other-functions/DECLARE",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq003",
        "db": "bigquery-public-data.google_analytics_sample",
        "question": "Compare the average pageviews per visitor between purchase and non-purchase sessions for each month from April to July in 2017.",
        "external_knowledge": "google_analytics_sample.ga_sessions.md",
        "plan": "1. Calculate average pageviews for non-purchase sessions:\n- Extracts the year and month from the `date` field.\n- Filters sessions with no transactions and no product revenue.\n- Aggregates data by month and calculates the average pageviews per visitor.\n2. Similarly, calculate average pageviews for purchase sessions. The difference is that we only include sessions with at least one transaction and product revenue.\n3. Combine and compare the results, that is select and order results by month.",
        "special_function": [
            "date-functions/DATE",
            "date-functions/EXTRACT",
            "date-functions/PARSE_DATE",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "string-functions/CONCAT",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq004",
        "db": "bigquery-public-data.google_analytics_sample",
        "question": "What's the most popular other purchased product in July 2017 with consumers who bought products relevant to YouTube?",
        "external_knowledge": "google_analytics_sample.ga_sessions.md",
        "plan": "1. Identify visitors who purchased any YouTube product in July 2017.\n2. Calculate the total quantity of each product (excluding YouTube products) purchased by visitors who bought any YouTube product in July 2017.\n3. Retrieve the product name with the highest total quantity.",
        "special_function": [
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq008",
        "db": "bigquery-public-data.google_analytics_sample",
        "question": "What's the most common next page for visitors who were part of \"Data Share\" campaign and after they accessed the page starting with '/home' in January 2017. And what's the maximum duration time (in seconds) when they visit the corresponding home page?",
        "external_knowledge": "google_analytics_sample.ga_sessions.md",
        "plan": "1. Identify relevant visits and pages: extract sessions from the `ga_sessions_*` table within January 2017 that contain page hits with paths starting with '/home' and were part of the \"Data Share\" campaign.\n2. Generate visitor page sequence: combine the filtered sessions with their corresponding page hits to get the full visitor ID, visit ID, timestamp, and page path for each page visit. And order the pages by their visit timestamps.\n3. Calculate the next page and duration:\n   - Use the `LEAD` window function to determine the next page and calculate the duration spent on the current page (by subtracting the current timestamp from the next timestamp).\n   - Rank the pages within each session to maintain the sequence of page visits.\n4. Create the page visit sequence CTE: combine the results into a Common Table Expression (CTE) called that includes the visitor ID, visit ID, page path, duration on the page, next page path, and visit step number.\n5. Determine the most common next page after visiting '/home' page. From the table in Step 4, filter for entries where the current page path starts with '/home', group by the next page, and count occurrences to find the most common next page.\n6. Calculate the maximum duration on home pages. Filter for entries where the current page path starts with '/home' and return the maximum duration spent on it.\n7. Combine and return the results in Step 5 and Step 6, which include the most common next page and the maximum duration.",
        "special_function": [
            "navigation-functions/LEAD",
            "numbering-functions/RANK",
            "string-functions/REGEXP_CONTAINS",
            "timestamp-functions/TIMESTAMP",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq029",
        "db": "patents-public-data.patents",
        "question": "Get the number of patent publications and the average number of inventors per patent in the US every five years from 1945 to 2020?",
        "external_knowledge": null,
        "plan": "1.Extract information on patent applications in the United States since 1945.\n2.Divide the data into five-year intervals.\n3.Within each interval, count the number of applicants for each patent, ensuring each patent has more than zero applicants.\n4.Calculate both the total number of patents and the average number of applicants per patent for each interval.",
        "special_function": [
            "aggregate-functions/ANY_VALUE",
            "array-functions/ARRAY_LENGTH",
            "conversion-functions/CAST",
            "mathematical-functions/FLOOR"
        ]
    },
    {
        "instance_id": "bq026",
        "db": "patents-public-data.patents",
        "question": "For the assignee who has been the most active in the patent category 'A61K39', I'd like to know the five patent jurisdictions code where they filed the most patents during their busiest year, separated by commas.",
        "external_knowledge": null,
        "plan": "1. First, access the patents database to retrieve all patent application data where the CPC code matches \"A61K39\".\n2. For each assignee, categorize the data by year and country of application.\n3. Identify the top five countries with the most applications for each assignee per year.\n4. Sort to find out which assignee has the highest total number of applications.\n5. Select the year with the most applications for this assignee.",
        "special_function": [
            "aggregate-functions/ANY_VALUE",
            "aggregate-functions/ARRAY_AGG",
            "aggregate-functions/GROUPING",
            "aggregate-functions/STRING_AGG",
            "conversion-functions/CAST",
            "mathematical-functions/FLOOR",
            "string-functions/REGEXP_CONTAINS",
            "conditional-functions/IF",
            "other-functions/UNNEST",
            "other-functions/ARRAY_SUBSCRIPT"
        ]
    },
    {
        "instance_id": "bq026_1",
        "db": "patents-public-data.patents",
        "question": "In which year did the assignee with the most applications in the patent category 'A61K39' file the most?",
        "external_knowledge": null,
        "plan": "1. First, access the patents database to retrieve all patent application data where the CPC code matches \"A61K39\".\n2. For each assignee, categorize the data by year and country of application.\n3. Identify the assignee with the most total applications for the \u201cA61K39\u201d patent.\n4. Select the year with the most applications for this assignee",
        "special_function": [
            "aggregate-functions/ANY_VALUE",
            "aggregate-functions/GROUPING",
            "array-functions/ARRAY",
            "conversion-functions/CAST",
            "date-functions/DATE",
            "mathematical-functions/FLOOR",
            "string-functions/REGEXP_CONTAINS",
            "conditional-functions/IF",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq026_2",
        "db": "patents-public-data.patents",
        "question": "For patent class A01B3, I want to analyze the information of the top 20 assignees based on the total number of applications. Please provide the following five pieces of information: the names of these assignees, their total number of applications, the year with the most applications, the number of applications in that year, and the country code with the most applications during that year.",
        "external_knowledge": null,
        "plan": "1. **Filter Patent Data**: \n   - Identify and collect patent applications related to a specific patent class.\n   - Ensure each application is uniquely identified and includes relevant assignee, filing date, and country information.\n\n2. **Count Applications by Assignee, Year, and Country**:\n   - For each application, determine the number of filings per assignee, broken down by year and country.\n   - Group the data by assignee name, year, and country to prepare for aggregation.\n\n3. **Aggregate Yearly Application Data**:\n   - Summarize the total number of applications for each assignee by year.\n   - Identify the country with the highest number of applications for each assignee and year.\n\n4. **Determine Peak Application Year for Each Assignee**:\n   - Calculate the overall number of applications for each assignee.\n   - Identify the year with the highest application count and the corresponding country with the most applications for each assignee.\n\n5. **Select and Rank Top Assignees**:\n   - Order the assignees by their total number of applications in descending order.\n   - Limit the results to the top 20 assignees, including their total application count, the year with the highest applications, the number of applications in that year, and the most frequent country code during that year.",
        "special_function": [
            "aggregate-functions/ANY_VALUE",
            "aggregate-functions/ARRAY_AGG",
            "aggregate-functions/GROUPING",
            "aggregate-functions/STRING_AGG",
            "conversion-functions/CAST",
            "mathematical-functions/FLOOR",
            "string-functions/REGEXP_CONTAINS",
            "other-functions/UNNEST",
            "other-functions/ARRAY_SUBSCRIPT"
        ]
    },
    {
        "instance_id": "bq033",
        "db": "patents-public-data.patents",
        "question": "How many US patent applications about IoT applications were filed each month from 2008 to 2022?",
        "external_knowledge": null,
        "plan": "1. Extract patents with abstracts containing \"Internet of Things\" that were applied for in the United States.\n2. Generate a record set starting from January 2008 to December 2022.\n3. Count and record the number of \"Internet of Things\" patents applied for each month.\n4. Sort and return the monthly totals with the highest number of patent applications.",
        "special_function": [
            "aggregate-functions/ANY_VALUE",
            "array-functions/GENERATE_DATE_ARRAY",
            "conversion-functions/SAFE_CAST",
            "date-functions/DATE",
            "date-functions/FORMAT_DATE",
            "date-functions/PARSE_DATE",
            "json-functions/STRING",
            "string-functions/LOWER",
            "timestamp-functions/STRING",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq209",
        "db": "patents-public-data.patents",
        "question": "Could you find out which US utility patent granted in January 2010, with a published application, has the most forward citations over the ten years following its application date?",
        "external_knowledge": null,
        "plan": "1. Retrieve all patents granted in January 2010, considering only those with the kind code B2, which are utility patents issued with a published application.\n2. Query other patents to extract forward citation information from patent publications, ensuring that the citation date of the citing patent falls within ten years of the filing date of the cited patent.\n3. Calculate the number of distinct citation applications for each patent to identify the patent with the most citations.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/DATE_ADD",
            "date-functions/PARSE_DATE",
            "json-functions/STRING",
            "timestamp-functions/STRING",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq027",
        "db": "patents-public-data.patents",
        "question": "For US B2 patents granted in the first seven days of January 2018, tell me the publication number of each patent and the number of backward citations it has received in the SEA category.",
        "external_knowledge": null,
        "plan": "1. **Define the Initial Dataset**: Create a temporary dataset that includes the publication number and application number of patents.\n    - Filter for patents from a specific country.\n    - Ensure the patents have a grant date within the first week of January 2018.\n    - Exclude any entries without a grant date.\n    - Include only patents with a specific kind code.\n\n2. **Create the Main Query**: Use the temporary dataset to find the required information.\n    - Select the publication number from the temporary dataset.\n\n3. **Join with Citation Data**: Perform a left join with another table that contains citation details.\n    - Extract the citing publication number, cited publication number, and category from the citation details.\n    - Ensure that the citation category contains a specific keyword.\n\n4. **Join with Publication Data Again**: Perform another left join to link the cited publication number with the application number from the publication data.\n\n5. **Aggregate the Results**: Group the results by the publication number from the initial dataset.\n    - Count the distinct application numbers that are cited by the patents in the specified category.\n\n6. **Order the Results**: Sort the final results by the publication number.",
        "special_function": [
            "string-functions/CONTAINS_SUBSTR",
            "string-functions/LEFT",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq210",
        "db": "patents-public-data.patents",
        "question": "How many US B2 patents granted between 2015 and 2018 contain claims that do not include the word 'claim'?",
        "external_knowledge": null,
        "plan": "1. **Extract Relevant Patent Data**: Create a temporary dataset by selecting publication numbers and their associated claims from the main data source. Ensure that only patents granted in the US between the years 2015 and 2018 are included. Also, filter to include only those patents whose publication numbers end with 'B2'.\n\n2. **Unnest Claims**: Expand the nested claims data so that each claim associated with a patent is treated as a separate row in the temporary dataset.\n\n3. **Filter Claims Text**: Check each claim text to see if it does not contain the word 'claim'. Count the number of such claims for each publication number.\n\n4. **Group by Publication Number**: Aggregate the results by publication number, counting how many claims per patent do not contain the word 'claim'.\n\n5. **Filter Non-zero Counts**: From the aggregated data, select only those patents that have at least one claim not containing the word 'claim'.\n\n6. **Final Count**: Count the number of patents that meet the criteria established in the previous steps. This final result represents the number of US B2 patents granted between 2015 and 2018 that have at least one claim not containing the word 'claim'.",
        "special_function": [
            "aggregate-functions/COUNTIF",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq211",
        "db": "patents-public-data.patents",
        "question": "Among the US utility B2 patents granted in January 2008, how many of them belong to families that have a total of over 300 distinct applications?",
        "external_knowledge": null,
        "plan": "1.Extract information on patents that were applied for and granted in the United States in January 2008.\n2.Obtain the family IDs associated with these patents.\n3.Retrieve the total number of patents within these families.\n4.Keep the application IDs of patents where the family size exceeds 300 and count their total number.",
        "special_function": null
    },
    {
        "instance_id": "bq213",
        "db": "patents-public-data.patents",
        "question": "What is the most common 4-digit IPC code among US B2 utility patents granted in the first seven days of June 2018?",
        "external_knowledge": "patents_info.md",
        "plan": "1.Data Retrieval: Access patents-public-data.patents.publications, unnest IPC codes, and filter for US patents granted in April 2015 with a 'B2' kind code.\n2.IPC Analysis: Extract the first four characters of each IPC code, count their occurrences within each patent, and group by publication number and IPC subcategory.\n3.Determine Dominance: For each patent, identify the most frequent IPC subcategory using a combination of concatenation and maximum count comparison within the grouped data.\n4.Result Extraction: Order the results by the count of IPC occurrences and limit the output to the top entry to find the single most prevalent IPC subcategory.",
        "special_function": [
            "string-functions/SUBSTR",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq213_1",
        "db": "patents-public-data.patents",
        "question": "For US B2 utility patents granted in April 2015, identify the most frequent 4-digit IPC code for each patent. Then, list the publication numbers and IPC4 codes of patents where this code appears 20 or more times.",
        "external_knowledge": "patents_info.md",
        "plan": "1. **Create an Interim Table:**\n   - Select the publication number and extract the first 4 characters of the IPC code.\n   - Count the occurrences of each 4-character IPC code for each publication.\n   - Filter records to include only those from the specified country and date range, ensuring the grant date is valid and the publication format matches the specified pattern.\n   - Group the results by publication number and the 4-character IPC code.\n\n2. **Identify Most Frequent IPC Code:**\n   - In the interim table, determine the most frequent 4-character IPC code for each publication.\n   - Concatenate the publication number with the count of the most frequent IPC code.\n   - Use this concatenated value to filter the interim table, ensuring you select rows where the IPC code count matches the maximum count for each publication.\n\n3. **Filter by Frequency:**\n   - Further filter the results to include only those rows where the most frequent IPC code appears 20 or more times.\n\n4. **Final Selection:**\n   - From the filtered results, select and list the publication numbers and their corresponding 4-character IPC codes.",
        "special_function": [
            "string-functions/CONCAT",
            "string-functions/SUBSTR",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq214",
        "db": "patents-public-data.patents",
        "question": "For the 'B2' publication granted in January 2017 in the US that received the most forward citations within a month of its filing date, determine the publication number of the most similar patent from the same filing year.",
        "external_knowledge": "patents_info.md",
        "plan": "1.Extract Relevant Patent Data: Access the patents database to retrieve information for patents granted in the US on June 2nd, 2015, with the kind code B2, indicating they are granted utility patents.\n2.Determine the IPC Codes: For each patent, extract and count occurrences of four-digit IPC codes from the abstracts, identifying how frequently each IPC code appears within a given patent.\n3.Identify Backward Citations: For each selected patent, retrieve backward citations (i.e., earlier patents cited by the patent in question) and join these with the IPC data to analyze the diversity of IPC codes from these citations.\n4.Calculate Originality Score: Compute an originality score for each patent based on the diversity of IPC codes cited. This involves calculating a formula where the diversity is inversely related to the sum of the squares of IPC code occurrences.\n5.Select the Patent with the Highest Originality: From the calculated originality scores, identify the patent with the highest score, which indicates it has the broadest range of influences from prior art, suggesting a high level of innovation.\n6.Output the Result: Return the publication number of the patent with the highest originality score, highlighting it as the most original patent granted on that specific day.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/DATE_ADD",
            "date-functions/EXTRACT",
            "date-functions/PARSE_DATE",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "json-functions/STRING",
            "numbering-functions/ROW_NUMBER",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "timestamp-functions/STRING",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq214_1",
        "db": "patents-public-data.patents",
        "question": "Identify the top five patents filed in the same year as `US-9023721-B2` that are most similar to it based on technological similarities. Please provide the publication numbers.",
        "external_knowledge": "patents_info.md",
        "plan": "1. **Extract the Target Patent**: Create a subset containing only the target patent's unique identifiers.\n\n2. **Calculate Filing Year for Target Patent**: Determine the filing year of the target patent by extracting the year from its filing date.\n\n3. **Identify Same-Year Patents**: Retrieve all patents filed in the same year as the target patent, excluding the target patent itself.\n\n4. **Calculate Technological Similarity**: For each patent from the same year, compute the technological similarity with the target patent using a predefined similarity metric based on their respective embeddings.\n\n5. **Rank Similar Patents**: Order the patents by their similarity scores in descending order.\n\n6. **Select Top Similar Patents**: From the ordered list, select the top five patents with the highest similarity scores for each target patent.\n\n7. **Output Similar Patents**: Return the publication numbers and similarity scores of the top five most similar patents.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/EXTRACT",
            "date-functions/PARSE_DATE",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "json-functions/STRING",
            "numbering-functions/ROW_NUMBER",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "timestamp-functions/STRING"
        ]
    },
    {
        "instance_id": "bq215",
        "db": "patents-public-data.patents",
        "question": "What is the publication number of US patent granted at January 2018, with the highest originality score based on the diversity of 4-digits IPC codes from its backward citations?",
        "external_knowledge": "patents_info.md",
        "plan": "1. **Filter US Patents:**\n   - Select publication numbers and application numbers from the dataset.\n   - Only include records where the country code is 'US'.\n   - Ensure the grant date is within January 2018.\n   - Exclude records with a grant date of 0.\n   - Only consider patents with a specific kind code pattern.\n\n2. **Extract IPC Codes:**\n   - For each selected patent, extract and count the unique 4-digit IPC codes from the associated IPC codes.\n\n3. **Identify Maximum IPC Code Count:**\n   - Create a subset of records that have the maximum count of a specific 4-digit IPC code for each patent.\n\n4. **Calculate IPC Occurrences in Backward Citations:**\n   - Join the filtered patents with their backward citations.\n   - For each backward citation, join with the subset of records to get the 4-digit IPC codes.\n   - Count the occurrences of each 4-digit IPC code in the backward citations for each patent.\n\n5. **Compute Originality Score:**\n   - For each patent, calculate an originality score based on the diversity of the 4-digit IPC codes from the backward citations.\n   - Use a formula that considers the sum of squared occurrences of each IPC code, normalized by the total number of occurrences.\n\n6. **Select Highest Originality Score:**\n   - From the computed originality scores, select the patent with the highest score.\n\n7. **Return Result:**\n   - Output the publication number of the patent with the highest originality score.",
        "special_function": [
            "mathematical-functions/POWER",
            "string-functions/CONCAT",
            "string-functions/SUBSTR",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq221",
        "db": "patents-public-data.patents\npatents-public-data.cpc",
        "question": "Identify the CPC technology areas with the highest exponential moving average of patent filings each year (smoothing factor 0.2), and provide the full title and the best year for each CPC group at level 5.",
        "external_knowledge": null,
        "plan": "1. First, we define a temporary JavaScript function, which is used to calculate the year with the highest moving average of patent counts.\n2. Use common table expression to extract the CPC codes and filing years for patents, ensuring each patent has an application number and valid filing date. Also filter to include only the primary CPC code (`first = TRUE`).\n3. Calculate the most common patenting technology areas by year and identify the year with the highest moving average of patents for each CPC group. Concretely,\n- Aggregate patent counts by CPC group and filing year.\n- Use the defined function in Step 1. to find the year with the highest moving average of patents for each CPC group.\n- Join the results with the CPC definition table to get the full title for each CPC group. Remember, only include level 5 CPC groups.",
        "special_function": [
            "aggregate-functions/ANY_VALUE",
            "aggregate-functions/ARRAY_AGG",
            "conversion-functions/CAST",
            "mathematical-functions/FLOOR",
            "conditional-functions/IF",
            "other-functions/CREATE_FUNCTION",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq222",
        "db": "patents-public-data.patents",
        "question": "Find the CPC technology areas in Germany with the highest exponential moving average of patent filings each year (smoothing factor 0.1) for patents granted in December 2016. Show me the full title, CPC group and the best year for each CPC group at level 4.",
        "external_knowledge": null,
        "plan": "1. Firstly, we create a temporary function to calculate the highest moving average of patent counts.\n2. Use a common table expression to extract CPC codes and filing years for patents granted in Germany between 2016-12-01 to 2016-12-31, including only the primary CPC code.\n3. Calculate the highest moving average of patent counts for each CPC group, record the filing year information.\n4. Combine the results with CPC definitions to get the full title and also return the results with CPC group and filing year.",
        "special_function": [
            "aggregate-functions/ANY_VALUE",
            "aggregate-functions/ARRAY_AGG",
            "conversion-functions/CAST",
            "mathematical-functions/FLOOR",
            "conditional-functions/IF",
            "other-functions/CREATE_FUNCTION",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq223",
        "db": "patents-public-data.patents\npatents-public-data.cpc",
        "question": "Which assignee and primary CPC subclass full title most frequently cite patents assigned to 'AAAA'?",
        "external_knowledge": null,
        "plan": "1. Firstly, extract citing publication and cited publication details, including only the primary CPC code.\n2. Combine the citing and cited data according the publication number.\n3. Join with CPC definition information to extract CPC subclass title.\n4. Add filter to include only relevant citations.\n5. Group the results by citing assignee and CPC full title, count the citations and order the result by count.\nWe only return the most frequent assignee and CPC subclass title.",
        "special_function": [
            "string-functions/SUBSTR",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq247",
        "db": "patents-public-data.patents\npatents-public-data.google_patents_research",
        "question": "Which valid family has the most publications? Just provide their publication abstracts.",
        "external_knowledge": null,
        "plan": "1. Aggregate the data to count the number of publications per unique family identifier.\n2. Select the family identifier that has the highest publication count, ensuring that only valid identifiers are considered.\n3. Filter the dataset to include only those records that have a non-empty abstract. \n4. Join the filtered list of publications with the most published family identifier obtained earlier to get a dataset containing only the abstracts from publications that belong to the family with the highest publication count.\n5. Retrieve and display the abstracts from publications associated with the family having the most publications. \n",
        "special_function": null
    },
    {
        "instance_id": "bq246",
        "db": "patents-public-data.patentsview",
        "question": "Can you figure out the number of forward citations within 3 years from the application date for the patent that has the most backward citations within 3 years from application among all U.S. patents?",
        "external_knowledge": null,
        "plan": "1. Correlate patent applications with patent citations based on patent identifiers. Ensure that only patents registered in the US are considered.\n2. Compute citations where the citation date is between the application date and three years after.\n3. Compute citations where the citation date is between three years prior to the application date and the application date itself.\n4. Join the information about current patent classifications with the aggregated citation data.\n5. Merge the detailed citation data with the patent applications data.\n6. Sort the resulting data set by the count of backward citations in descending order and restrict the output to the top record to find the patent with the highest count of backward citations within the specified period.\n7. From the final sorted and limited dataset, extract the count of forward citations for the patent with the highest number of backward citations. \n",
        "special_function": [
            "conversion-functions/SAFE_CAST",
            "date-functions/DATE",
            "date-functions/DATE_ADD",
            "date-functions/DATE_SUB",
            "conditional-functions/IFNULL"
        ]
    },
    {
        "instance_id": "bq052",
        "db": "patents-public-data.patentsview",
        "question": "I wonder which patents within CPC subsection 'C05' or group 'A01G' in the USA have at least one forward or backward citations within one month of their application dates. Give me the ids, titles, application date, forward/backward citation counts and summary texts.",
        "external_knowledge": null,
        "plan": "1. Identify Relevant Patents:\n   - Select patents in the USA that belong to specific CPC categories (either a particular subsection or group).\n\n2. Citation Filtering:\n   - Determine patents with at least one forward or backward citation within one month of their application dates. Count these citations separately for forward and backward directions.\n\n3. Data Aggregation:\n   - For each relevant patent, gather the patent ID, title, application date, forward and backward citation counts, and summary text.\n\n4. Combine and Order Results:\n   - Join the relevant patent data with citation counts and summary texts, and then order the results by the application date.",
        "special_function": [
            "conversion-functions/SAFE_CAST",
            "date-functions/DATE",
            "date-functions/DATE_ADD",
            "date-functions/DATE_SUB",
            "conditional-functions/IFNULL"
        ]
    },
    {
        "instance_id": "bq207",
        "db": "patents-public-data.patents\npatents-public-data.uspto_peds",
        "question": "Can you provide the initial publication numbers for our top 100 independent patent claims with the highest word count?",
        "external_knowledge": null,
        "plan": "1.Select Independent Claims: Extract patent number, claim number, and word count for independent claims.\n2.Match Publication Numbers: Join with the match table to get the corresponding publication numbers.\n3.Match Application Numbers and Publication Information: Join with the publications table to get application details and select the earliest publication for each application.\n4.Select and Order Results: Retrieve all fields, order by word count in descending order, and limit to the top 100 records.",
        "special_function": [
            "conversion-functions/CAST",
            "json-functions/STRING",
            "numbering-functions/ROW_NUMBER",
            "timestamp-functions/STRING",
            "conditional-functions/IF"
        ]
    },
    {
        "instance_id": "bq036",
        "db": "bigquery-public-data.github_repos",
        "question": "What was the average number of GitHub commits made per month in 2020 for repositories containing Python code?",
        "external_knowledge": null,
        "plan": "1. Find out the table containing all commit info: `bigquery-public-data.github_repos.commits`\n2. Filter out the commit info in 2020, and for each commit-repo pair save its YearMonth timestamp.\n3. Find `bigquery-public-data.github_repos.languages` table, and range the data in commit - language entries.\n4. Combine them to find the commits which contain Python language and were made in  2020. Group the data according to YearMonth and calculate the number of commits for each month.\n5. Calculate the average monthly number of commits.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "json-functions/STRING",
            "string-functions/CONCAT",
            "string-functions/LPAD",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "timestamp-functions/STRING",
            "timestamp-functions/TIMESTAMP_SECONDS",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq100",
        "db": "bigquery-public-data.github_repos",
        "question": "Find out the most frequently used package in all Go source files.",
        "external_knowledge": null,
        "plan": "1. Extract Imports from File Contents (imports CTE):\n- Selects id and lines containing imports from files where the content matches the regex pattern r'import\\s*\\([^)]*\\)'.\n- SPLIT(REGEXP_EXTRACT(content, r'import\\s*\\(([^)]*)\\)'), '\\n') extracts the content inside the import(...) block and splits it into individual lines.\n2. Filter Go Files (go_files CTE):\n- Selects the id of files that have paths ending with .go (Go source files).\n- Uses GROUP BY id to ensure unique file IDs.\n3. Unnest Lines of Imports (filtered_imports CTE): Unnests the lines from the imports CTE to get each line as a separate row, resulting in rows with id and line.\n4. Join Imports with Go Files (joined_data CTE): Joins the filtered_imports with go_files on the id to filter only those import lines that belong to Go files.\n5. Extract the Package (SELECT statement):\n- Extracts the imported package using REGEXP_EXTRACT(line, r'\"([^\"]+)\"').\n- Filters out NULL string.\n- Groups the results by package, counts the occurrences, orders by the count in descending order, and limits the result to the most frequently imported package.",
        "special_function": [
            "string-functions/REGEXP_CONTAINS",
            "string-functions/REGEXP_EXTRACT",
            "string-functions/SPLIT",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq101",
        "db": "bigquery-public-data.github_repos",
        "question": "Identify the top 10 most frequently imported packages and their counts in Java source files.",
        "external_knowledge": null,
        "plan": "1. Filter java source files: select Java files containing the \"import\" keyword.\n- condition: sample_path LIKE '%.java' to filter Java files.\n- condition: REGEXP_CONTAINS(content, r'import') to ensure the file contains \"import\" statements.\n2. Split the file content into lines and extract the import lines.\n3. Extract the package names with regex expression `r'([a-z0-9\\._]*)\\.'` to capture the package names.\n4. Count the number of imports for each package using GROUP BY clause.\n5. Order the results by count in descending order and limits to the top 10 packages.",
        "special_function": [
            "string-functions/LEFT",
            "string-functions/REGEXP_CONTAINS",
            "string-functions/REGEXP_EXTRACT",
            "string-functions/SPLIT",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq182",
        "db": "bigquery-public-data.github_repos\ngithubarchive.day",
        "question": "Which primary programming languages, determined by the highest number of bytes in each repository, have its repositories having at least a total of 100 pull requests on January 18, 2023?",
        "external_knowledge": null,
        "plan": "1. Extract event data from `githubarchive.day.20230118` db and get repo name from url.\n2. combine with the db `bigquery-public-data.github_repos.languages` to group the event data by the language of its repo.\n3. Filter to keep the data that has a type of 'PullRequestEvent' and a count of more than 100.",
        "special_function": [
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "navigation-functions/FIRST_VALUE",
            "string-functions/REGEXP_REPLACE",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "conditional-functions/IF",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq182_1",
        "db": "bigquery-public-data.github_repos\ngithubarchive.day",
        "question": "How many pull requests in total were created in repositories that include JavaScript as one of their languages, considering data from January 18, 2023?",
        "external_knowledge": null,
        "plan": "1. **Subquery `a` - Extract and Transform Data from `githubarchive` Table:**\r\n   - **Select Fields:** Extract the `type`, the year (`y`), and the quarter (`q`) from the `created_at` column.\r\n   - **Regular Expression Replace:** Clean the `repo.url` to extract the repository name, removing specific URL patterns.\r\n   - **Data Source:** Pull data from the `githubarchive.day.20230118` table.\r\n\r\n2. **Subquery `b` - Filter and Aggregate Data from `github_repos.languages`:**\r\n   - **Nested Subquery:** \r\n     - **Unnest Languages:** Expand the `languages` array to individual rows.\r\n     - **Select Fields:** Extract `repo_name` and `language` details.\r\n   - **Filter Language:** Retain only rows where `language` is 'JavaScript'.\r\n   - **Group By:** Aggregate by `repo_name` and `language` to ensure unique combinations.\r\n\r\n3. **Join Subquery `a` and Subquery `b`:**\r\n   - **Join Condition:** Match `name` from subquery `a` with `name` from subquery `b`.\r\n\r\n4. **Filter by Event Type:**\r\n   - **Condition:** Retain only rows where `type` is 'PullRequestEvent'.\r\n\r\n5. **Count the Results:**\r\n   - **Aggregate Function:** Count the total number of resulting rows and alias the result as `total_pull_requests`.\r\n\r\n6. **Final Output:**\r\n   - **Select Statement:** Return the total count of pull request events for repositories where the language is 'JavaScript'.",
        "special_function": [
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "string-functions/REGEXP_REPLACE",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "conditional-functions/IF",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq191",
        "db": "bigquery-public-data.github_repos\ngithubarchive.year",
        "question": "Find the top 5 repositories from 2017, which have more than 300 unique users watching them, that also have a `pom.xml` file containing the text `<artifactId>junit</artifactId>`. List these repositories in descending order of the watches they have.",
        "external_knowledge": null,
        "plan": "1. **Define CTE `repos`:**\r\n   - **Subquery `a`:**\r\n     - Select distinct repository names from the `sample_files` table, assigning the result to `repo_in_mirror`.\r\n   - **Subquery `b`:**\r\n     - Select repository names and approximate count of distinct actors who performed 'WatchEvent' in 2017 from `githubarchive.year.2017`, filtering for repositories with more than 300 stars.\r\n   - **Join `a` and `b`:**\r\n     - Perform a RIGHT JOIN on `a` and `b` using `repo_in_mirror` and `repo_with_stars` to keep all repositories with stars from subquery `b`.\r\n     - Filter out rows where `repo_in_mirror` is NULL.\r\n   - **Result:**\r\n     - CTE `repos` contains repository names and their star counts for repositories with more than 300 stars and which exist in `sample_files`.\r\n\r\n2. **Define CTE `contents`:**\r\n   - **Subquery `a`:**\r\n     - Select distinct entries from `sample_files` where the repository name exists in the `repos` CTE.\r\n   - **Subquery `b`:**\r\n     - Select content ID and content from `sample_contents`.\r\n   - **Join `a` and `b`:**\r\n     - Perform a RIGHT JOIN on `a` and `b` using the content ID.\r\n   - **Result:**\r\n     - CTE `contents` contains all content entries linked to repositories listed in the `repos` CTE.\r\n\r\n3. **Final Query:**\r\n   - **Join `repos` and `contents`:**\r\n     - Join `repos` with `contents` on `repo_name`.\r\n   - **Filter Results:**\r\n     - Filter for rows where the content contains the string '%junit</artifactId>%'.\r\n     - Filter for rows where the path is 'pom.xml'.\r\n   - **Order and Limit Results:**\r\n     - Order the results by the number of stars in descending order.\r\n     - Limit the output to the top 5 rows.\r\n\r\n4. **Output:**\r\n   - Select repository names and star counts from the filtered and joined results.",
        "special_function": [
            "approximate-aggregate-functions/APPROX_COUNT_DISTINCT"
        ]
    },
    {
        "instance_id": "bq224",
        "db": "bigquery-public-data.github_repos\ngithubarchive.month",
        "question": "Which repository with an approved license in `licenses.md` had the highest combined total of forks, issues, and watches in April 2022?",
        "external_knowledge": null,
        "plan": "1. Filter only those repositories whose licenses are listed in the provided array of approved licenses.\n2. Select repository names and count distinct users who watched the repositories, that is to include only `WatchEvent` types.\n3. Similarly, select repository names and count the number of issues (`IssuesEvent`) and forks (`ForkEvent`).\n4. Combine the data and calculate the total counts of forks, issue events, and watches for each repository.\n5. Sort the results in descending order and only return the top repository name.",
        "special_function": [
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq192",
        "db": "bigquery-public-data.github_repos",
        "question": "Which repository that has a license of either \"artistic-2.0\", \"isc\", \"mit\", or \"apache-2.0\", contains Python files in the master branch, and has the highest combined count of forks, issues, and watch events in April 2022?",
        "external_knowledge": null,
        "plan": "1. **Define Allowed Repos:**\r\n   - Create a Common Table Expression (CTE) named `allowed_repos` to filter repositories that have specific licenses (`artistic-2.0`, `isc`, `mit`, `apache-2.0`).\r\n   - Select `repo_name` and `license` from the `bigquery-public-data.github_repos.licenses` table where the license matches one of the specified values.\r\n\r\n2. **Calculate Watch Counts:**\r\n   - Create a CTE named `watch_counts` to calculate the number of unique watch events per repository.\r\n   - Select the repository name and count the distinct `actor.login` from the `githubarchive.month.202204` table where the event type is `WatchEvent`.\r\n   - Group by repository name.\r\n\r\n3. **Calculate Issue Counts:**\r\n   - Create a CTE named `issue_counts` to calculate the number of issue events per repository.\r\n   - Select the repository name and count the total number of events from the `githubarchive.month.202204` table where the event type is `IssuesEvent`.\r\n   - Group by repository name.\r\n\r\n4. **Calculate Fork Counts:**\r\n   - Create a CTE named `fork_counts` to calculate the number of fork events per repository.\r\n   - Select the repository name and count the total number of events from the `githubarchive.month.202204` table where the event type is `ForkEvent`.\r\n   - Group by repository name.\r\n\r\n5. **Combine Metadata:**\r\n   - Create a CTE named `metadata` to combine the information from `allowed_repos`, `fork_counts`, `issue_counts`, and `watch_counts`.\r\n   - Perform INNER JOIN operations between `allowed_repos` and the other CTEs (`fork_counts`, `issue_counts`, and `watch_counts`) on `repo_name`.\r\n   - Select `repo_name`, `license`, `forks`, `issue_events`, and `watches` from the combined data.\r\n\r\n6. **Identify Repos with Python Files:**\r\n   - Create a CTE named `github_files_at_head` to identify repositories that have Python files at the head of the master branch.\r\n   - Select `repo_name` from the `bigquery-public-data.github_repos.sample_files` table where `ref` is `\"refs/heads/master\"`, the file path ends with `.py`, and `symlink_target` is `NULL`.\r\n   - Group by `repo_name`.\r\n\r\n7. **Select Top Repository:**\r\n   - Perform an INNER JOIN between `metadata` and `github_files_at_head` on `repo_name`.\r\n   - Select the `repo_name` from `metadata` as `repository`.\r\n   - Order the results by the sum of `forks`, `issue_events`, and `watches` in descending order.\r\n   - Limit the result to the top repository.\r\n\r\n8. **Return Result:**\r\n   - The final query returns the repository name of the top repository with the highest combined count of forks, issue events, and watches among those that have Python files at the head of the master branch and have an allowed license.",
        "special_function": [
            "string-functions/ENDS_WITH",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq225",
        "db": "bigquery-public-data.github_repos",
        "question": "What's the top 3 widely used languages according to file counts?",
        "external_knowledge": "lang_and_ext.md",
        "plan": "1. Extract languages for each file according to file extensions.\n    - Determine the programming language based on the file extension extracted from the `path` field of the `files` table.\n    - Use the `REGEXP_EXTRACT` function to extract the file extension.\n    - Use a `CASE` statement to map file extensions to their respective languages based on the provided document `lang_and_ext.md`.\n2. Perform an inner join between the `languages` CTE and the `sample_contents` table on the `id` column. This join ensures that only files which have a corresponding content entry are considered.\n3. Filter out rows where `language` or `content` is `NULL`. This ensures that only valid and meaningful entries are included in the final result.\n4. Group and count by languages, and limit the final results to the top 3 entries.",
        "special_function": [
            "string-functions/REGEXP_EXTRACT"
        ]
    },
    {
        "instance_id": "bq180",
        "db": "bigquery-public-data.github_repos",
        "question": "Please help me retrieve the top 3 most frequently used module names from Python and R scripts.",
        "external_knowledge": null,
        "plan": "1. Get all the sample github file data and unnest the lines. Record the file path for each line.\n2. Extract the module names from the \"import\" and \"from\" statements of Python files, and the \"library(...)\" lines of R files.\n3. Count the number of occurences for each module and limit to the top 10 most used ones.",
        "special_function": [
            "array-functions/ARRAY_CONCAT",
            "string-functions/ENDS_WITH",
            "string-functions/REGEXP_CONTAINS",
            "string-functions/REGEXP_EXTRACT_ALL",
            "string-functions/REPLACE",
            "string-functions/SPLIT",
            "conditional-functions/IF",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq180_1",
        "db": "bigquery-public-data.github_repos",
        "question": "Can you find the top 5 most frequently imported Python modules and R libraries from the GitHub sample files and list them along with their occurrence counts? Please sort the results by language and then by the number of occurrences in descending order.",
        "external_knowledge": null,
        "plan": "1. **Extract File Information:**\r\n   - Join `sample_files` and `sample_contents` tables on `id` to get `file_id`, `repo_name`, `path`, and `content`.\r\n   - Split `content` into individual lines, treating each line as a separate record.\r\n\r\n2. **Identify and Extract Module Imports:**\r\n   - Create a CTE (`extracted_modules`) to filter and process lines containing import statements for Python (`import` or `from`) and R (`library`).\r\n   - For Python files (`.py`):\r\n     - Extract modules imported using `import` and `from` statements.\r\n     - Use `REGEXP_EXTRACT_ALL` to extract module names and concatenate results.\r\n   - For R files (`.r`):\r\n     - Extract modules imported using `library()` statements.\r\n     - Use `REGEXP_EXTRACT_ALL` to extract module names.\r\n   - Store extracted modules along with file information and detected language (Python or R).\r\n\r\n3. **Count Module Occurrences:**\r\n   - Create another CTE (`module_counts`) to count occurrences of each module per language.\r\n   - Unnest the modules array to have one module per row.\r\n   - Group by `language` and `module` and count occurrences.\r\n\r\n4. **Select Top 5 Modules for Python:**\r\n   - Create a CTE (`top5_python`) to select the top 5 most frequently used Python modules.\r\n   - Filter `module_counts` for `python` language.\r\n   - Order by `occurrence_count` in descending order.\r\n   - Limit results to 5.\r\n\r\n5. **Select Top 5 Modules for R:**\r\n   - Create a CTE (`top5_r`) to select the top 5 most frequently used R modules.\r\n   - Filter `module_counts` for `r` language.\r\n   - Order by `occurrence_count` in descending order.\r\n   - Limit results to 5.\r\n\r\n6. **Combine Results and Order:**\r\n   - Use `UNION ALL` to combine results from `top5_python` and `top5_r`.\r\n   - Order the final results by `language` and `occurrence_count` in descending order to display the top modules for each language.",
        "special_function": [
            "array-functions/ARRAY_CONCAT",
            "string-functions/ENDS_WITH",
            "string-functions/REGEXP_CONTAINS",
            "string-functions/REGEXP_EXTRACT_ALL",
            "string-functions/REPLACE",
            "string-functions/SPLIT",
            "conditional-functions/IF",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq248",
        "db": "bigquery-public-data.github_repos",
        "question": "Among all 'requirements.txt' files in repositories containing Python code, how much percentage of them include the 'requests' package?",
        "external_knowledge": null,
        "plan": "1. Get all ids and contents from table sample_contents.\n2. Extract ids, names and paths of github repositories which have requirements.txt.\n3. Extract names of github repositories whose language_name contains python.\n4. Identify the repositories whose requirements.txt contains \u2018requests\u2019.\n5. Count the number of python repositories whose requirements.txt contains \u2018requests\u2019.\n6. Count the number of python repositories which contain requirements.txt.\n7. Divide the above statistics to get the corresponding proportion.\n",
        "special_function": [
            "string-functions/LOWER",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq193",
        "db": "bigquery-public-data.github_repos",
        "question": "Help me find the third most frequently occurring non-empty line of text in `requirements.txt` files from GitHub repositories that primarily use Python for development.",
        "external_knowledge": null,
        "plan": "1. **Extract Content and Metadata**:\n   - Start by retrieving the repository content and metadata from the repository data source.\n   - Filter to include only files whose paths indicate they are `requirements.txt`.\n\n2. **Filter for Python Repositories**:\n   - Retrieve the list of repositories that primarily use Python for development.\n   - Join this list with the filtered files to ensure only files from Python repositories are considered.\n\n3. **Split File Content into Lines**:\n   - For each `requirements.txt` file, split its content into individual lines.\n\n4. **Filter Out Empty Lines**:\n   - Remove any lines that are empty or consist only of whitespace.\n\n5. **Calculate Line Frequencies**:\n   - Count the occurrences of each non-empty line across all the files.\n   - Sort these lines by their frequency of occurrence in descending order.\n\n6. **Retrieve the Third Most Frequent Line**:\n   - Select the line that is the third most frequently occurring from the sorted list.",
        "special_function": [
            "string-functions/LOWER",
            "string-functions/SPLIT",
            "string-functions/TRIM",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq295",
        "db": "bigquery-public-data.github_repos",
        "question": "Among the repositories from the GitHub Archive which include a Python file with less than 15,000 bytes in size and a keyword 'def' in the content, find the top 3 that have the highest number of watch events in 2017?",
        "external_knowledge": null,
        "plan": "1. **Common Table Expression (CTE) - `watched_repos`**:\n    - **Objective**: Extract repository names that have been watched.\n    - **Action**: \n        - Select `repo.name` as `repo` from the dataset `githubarchive.month.2017*` where the `type` is `\"WatchEvent\"`.\n\n2. **Common Table Expression (CTE) - `repo_watch_counts`**:\n    - **Objective**: Calculate the watch count for each repository.\n    - **Action**:\n        - Select `repo` and `COUNT(*)` as `watch_count` from the `watched_repos` CTE.\n        - Group the results by `repo` to aggregate watch counts.\n\n3. **Main Query - Data Source**:\n    - **Objective**: Fetch Python files with specific characteristics from GitHub repositories.\n    - **Action**:\n        - Select from `bigquery-public-data.github_repos.sample_files` as `f` and `bigquery-public-data.github_repos.sample_contents` as `c`.\n        - Join `f` and `c` on `f.id = c.id`.\n\n4. **Main Query - Additional Join**:\n    - **Objective**: Incorporate the watch counts into the main query.\n    - **Action**:\n        - Join the results from the previous step with `repo_watch_counts` as `r` on `f.repo_name = r.repo`.\n\n5. **Main Query - Filtering**:\n    - **Objective**: Filter the joined data to match specific criteria for Python files.\n    - **Action**:\n        - Apply a filter to select files where `f.path` ends with `.py`.\n        - Ensure the content size `c.size` is less than 15000 bytes.\n        - Check if the content `c.content` contains the pattern 'def ' using `REGEXP_CONTAINS`.\n\n6. **Main Query - Grouping and Ordering**:\n    - **Objective**: Prepare the final result set with grouping and sorting.\n    - **Action**:\n        - Group the results by `r.repo` and `r.watch_count`.\n        - Order the results by `r.watch_count` in descending order.\n\n7. **Main Query - Limiting Results**:\n    - **Objective**: Restrict the output to the top 3 repositories.\n    - **Action**:\n        - Use `LIMIT 3` to return only the top 3 repositories based on watch count.\n\n8. **Final Output**:\n    - **Objective**: Present the result.\n    - **Action**:\n        - Select and display the repository names and their corresponding watch counts.",
        "special_function": [
            "string-functions/REGEXP_CONTAINS"
        ]
    },
    {
        "instance_id": "bq249",
        "db": "bigquery-public-data.github_repos",
        "question": "Can you provide a report showing the counts of different types of lines in SQL files from the GitHub repository in descending order, specifically categorizing them into 'trailing' if there is at least one blank character at the end of the line, 'Space' if the line starts with at least one space, and 'Other' for any other types? ",
        "external_knowledge": null,
        "plan": "1. Filter records from a dataset where the file path ends with `.sql`.\n2. Use the `SPLIT` function to divide the content of each file into individual lines. This transformation creates an array of lines for each file.\n3. Each element (line) of the array is processed individually using the `CROSS JOIN UNNEST` technique. This flattens the array into a table format where each line is treated as a separate record.\n4. For each line, determine its type according to the definition of three types.\n5. Count how many lines fall into each indentation category ('trailing', 'Space', 'Other') across all files.\n6. Order the results by the count of occurrences in descending order.\n",
        "special_function": [
            "string-functions/CHAR_LENGTH",
            "string-functions/REGEXP_EXTRACT",
            "string-functions/SPLIT",
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq255",
        "db": "bigquery-public-data.github_repos",
        "question": "How many commit messages are there in repositories that use the 'Shell' programming language and 'apache-2.0' license, where the length of the commit message is more than 5 characters but less than 10,000 characters, and the messages do not start with the word 'merge', 'update' or 'test'?",
        "external_knowledge": null,
        "plan": "1. Retrieve repositories which have an 'apache-2.0' license.\n2. Retrieve repositories which have 'Shell' as one of its languages.\n3. Only keep messages whose length is greater than 5 and less than 10000.\n4. Remove messages containing \u2018update\u2019, \u2018test\u2019 or \u2018merge%\u2019.\n5. Count the selected messages and return.\n",
        "special_function": [
            "string-functions/LENGTH",
            "string-functions/LOWER",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq194",
        "db": "bigquery-public-data.github_repos",
        "question": "What is the second most frequently used module (imported library) across Python, R, and IPython script (.ipynb) files in the GitHub sample dataset?",
        "external_knowledge": null,
        "plan": "1. **Define CTE `extracted_modules`:**\r\n   - **Select Columns:**\r\n     - `file_id`, `repo_name`, `path`, `line`\r\n     - Determine `script_type` based on file extension:\r\n       - `.py` -> 'Python'\r\n       - `.r`, `.R`, `.Rmd`, `.rmd` -> 'R'\r\n       - `.ipynb` -> 'IPython'\r\n       - Others -> 'Others'\r\n     - Extract `modules` using regex based on `script_type`:\r\n       - For Python files, extract modules from `import` and `from` statements.\r\n       - For R files, extract modules from `library()` statements.\r\n       - For IPython notebooks, handle `import` and `from` statements within double quotes.\r\n   - **From Subquery:**\r\n     - Join `bigquery-public-data.github_repos.sample_files` and `bigquery-public-data.github_repos.sample_contents` on `id`.\r\n     - Select `file_id`, `repo_name`, `path`, and split `content` into `lines`.\r\n   - **Filter Lines:**\r\n     - For Python files, include lines containing `import` or `from ... import`.\r\n     - For R files, include lines containing `library()`.\r\n     - For IPython notebooks, include lines containing `import` or `from ... import` within double quotes.\r\n\r\n2. **Define CTE `unnested_modules`:**\r\n   - **Select Columns:**\r\n     - `file_id`, `repo_name`, `path`, `script_type`, `module`\r\n   - **From `extracted_modules`:**\r\n     - Unnest `modules` to get individual `module` names.\r\n\r\n3. **Define CTE `module_frequencies`:**\r\n   - **Select Columns:**\r\n     - `module`\r\n     - `script_type`\r\n     - Count occurrences of each `module` and `script_type` combination as `frequency`\r\n   - **From `unnested_modules`:**\r\n     - Group by `module`, `script_type`\r\n     - Order by `frequency` in descending order.\r\n\r\n4. **Final Select:**\r\n   - **Select Column:**\r\n     - `module`\r\n   - **From `module_frequencies`:**\r\n     - Order by `frequency` in descending order.\r\n     - Limit result to the second most frequent module (using `LIMIT 1 OFFSET 1`).",
        "special_function": [
            "string-functions/ENDS_WITH",
            "string-functions/REGEXP_CONTAINS",
            "string-functions/REGEXP_EXTRACT_ALL",
            "string-functions/REPLACE",
            "string-functions/SPLIT",
            "conditional-functions/IF",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq251",
        "db": "bigquery-public-data.github_repos\nspider2-public-data.pypi",
        "question": "Could you find the GitHub URL of the Python package that has the highest number of downloads on PyPi and was updated most recently? Please ensure that only the main repository URL is provided, excluding specific subsections like issues, blobs, pull requests, or tree views.",
        "external_knowledge": null,
        "plan": "1. Extract metadata including pypi_name, project_urls for PyPi packages.\n2. Filter the project_urls from PyPiData to extract clean GitHub repository URLs.\n3. Get the most recent version of each PyPi package based on the upload_time.\n4. Compute total downloads, yearly downloads for the past three years, and capture the earliest and latest download timestamps.\n5. Retrieve the number of watchers for each GitHub repository.\n6. Calculate the total bytes of code written in Python and the total bytes of code across all languages to get language data.\n7. Sort all data collected according to pypi_downloads and return the most downloaded package URL.\n",
        "special_function": [
            "numbering-functions/ROW_NUMBER",
            "string-functions/REGEXP_EXTRACT",
            "string-functions/REGEXP_REPLACE",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq252",
        "db": "bigquery-public-data.github_repos",
        "question": "Could you please find the name of the repository that contains the most copied non-binary Swift file in the dataset, ensuring each file is uniquely identified by its ID?",
        "external_knowledge": null,
        "plan": "1. Get file details and remove potential duplicates by file id.\n2. Filter the results to include only non-binary files with a `.swift` extension.\n3. Sort and return the name of the file which has the highest number of copies.",
        "special_function": null
    },
    {
        "instance_id": "bq019",
        "db": "bigquery-public-data.cms_medicare",
        "question": "For the most common inpatient diagnosis in the US in 2014, what was the citywise average payment respectively in the three cities that had the most cases?",
        "external_knowledge": null,
        "plan": "1. Decide which table to work on:  `bigquery-public-data.cms_medicare.inpatient_charges_2014`\n2. Rank all the diagnostic conditions by national number of cases to find the most common diagnostic condition.\n3. Group the data by diagnostic condition name, city and state, and calculate the citywise number of cases, citywise average payment for each entry.\n4. Accordingly, rank the cities by citywise number of cases for the most common diagnostic condition, and calculate the national avg. payments.\n5. Limit to the top 3 cities.",
        "special_function": [
            "conversion-functions/CAST",
            "mathematical-functions/ROUND",
            "numbering-functions/RANK"
        ]
    },
    {
        "instance_id": "bq019_1",
        "db": "bigquery-public-data.cms_medicare",
        "question": "What is the most prescribed medication in each state in 2014?",
        "external_knowledge": null,
        "plan": "1. Decide which table to work on:  `bigquery-public-data.cms_medicare.part_d_prescriber_2014`\n2. Group the data by drug name and state, and calculate the total claim count for each drug in each state.\n3. For each state, find out the max claim count number among different drugs. (most prescribed)\n4. List out corresponding most prescribed drug name for each state. (don\u2018t need to be in order",
        "special_function": [
            "mathematical-functions/ROUND"
        ]
    },
    {
        "instance_id": "bq019_2",
        "db": "bigquery-public-data.cms_medicare",
        "question": "Can you tell me which healthcare provider incurs the highest combined average costs for both outpatient and inpatient services in 2014?",
        "external_knowledge": null,
        "plan": "1. find out the corresponding table as described in the instruction `bigquery-public-data.cms_medicare.outpatient_charges_2014` and `bigquery-public-data.cms_medicare.inpatient_charges_2014`\r\n2. Group the outpatient charges data by different medical provider, and calculate the average outpatient cost per service.\r\n3. Do the same to inpatient charges data.\r\n4. Combine them to calculate the sum of two average costs for each medical provider.\r\n5. Rank them to find the peak. (the highest one)",
        "special_function": [
            "mathematical-functions/ROUND"
        ]
    },
    {
        "instance_id": "bq172",
        "db": "bigquery-public-data.cms_medicare",
        "question": "For the drug with the highest total number of prescriptions in New York State during 2014, could you list the top five states with the highest total claim counts for this drug? Please also include their total claim counts and total drug costs. ",
        "external_knowledge": null,
        "plan": "1. **Identify the Top Drug in NY:**\r\n   - Create a Common Table Expression (CTE) named `ny_top_drug`.\r\n   - Select the `generic_name` of drugs as `drug_name` and calculate the total number of claims (`total_claim_count`) for each drug.\r\n   - Filter the data to include only records where the provider state (`nppes_provider_state`) is 'NY'.\r\n   - Group the results by `drug_name`.\r\n   - Order the results by `total_claim_count` in descending order.\r\n   - Limit the results to the top drug (highest `total_claim_count`).\r\n\r\n2. **Identify the Top 5 States for the Top Drug:**\r\n   - Create a second CTE named `top_5_states`.\r\n   - Select the provider state (`nppes_provider_state`) as `state`, and calculate the total number of claims (`total_claim_count`) and total drug cost (`total_drug_cost`) for each state.\r\n   - Filter the data to include only records where the `generic_name` matches the top drug identified in `ny_top_drug`.\r\n   - Group the results by `state`.\r\n   - Order the results by `total_claim_count` in descending order.\r\n   - Limit the results to the top 5 states with the highest `total_claim_count`.\r\n\r\n3. **Return the Final Results:**\r\n   - Select the `state`, `total_claim_count`, and `total_drug_cost` from the `top_5_states` CTE to produce the final output.\r\n\r\nThis sequence ensures that we first determine the most prescribed drug in New York, then find the top 5 states where this drug is most frequently prescribed, and finally, present the relevant statistics for these states.",
        "special_function": [
            "mathematical-functions/ROUND"
        ]
    },
    {
        "instance_id": "bq172_1",
        "db": "bigquery-public-data.cms_medicare",
        "question": "For the provider with the highest total inpatient service cost from 2011-2015, tell me its annual inpatient and outpatient costs for each year during that period.",
        "external_knowledge": null,
        "plan": "1. **Identify Provider with Highest Inpatient Service Cost (2011-2015)**\r\n   - **Combine Inpatient Data:** Use `UNION ALL` to merge inpatient charge data from 2011 through 2015.\r\n   - **Calculate Total Inpatient Cost:** For each provider, compute the total inpatient cost as the sum of `average_medicare_payments` multiplied by `total_discharges`.\r\n   - **Find Top Provider:** Group the results by `provider_id`, order them by `total_ip_cost` in descending order, and limit the output to the top provider.\r\n\r\n2. **Extract Provider ID with Highest Inpatient Cost**\r\n   - **Select Provider ID:** From the previous step, extract the `provider_id` of the provider with the highest total inpatient service cost.\r\n\r\n3. **Retrieve Annual Inpatient Costs for Identified Provider (2011-2015)**\r\n   - **Query Inpatient Data:** For the identified provider, fetch the inpatient data from `cms_medicare.inpatient_charges_*`.\r\n   - **Calculate Annual Average Inpatient Cost:** Compute the average inpatient cost per year by averaging `average_medicare_payments` multiplied by `total_discharges`. Group the data by `provider_id`, `provider_state`, `provider_city`, `provider_name`, and year.\r\n\r\n4. **Retrieve Annual Outpatient Costs for Identified Provider (2011-2015)**\r\n   - **Query Outpatient Data:** For the identified provider, fetch the outpatient data from `cms_medicare.outpatient_charges_*`.\r\n   - **Calculate Annual Average Outpatient Cost:** Compute the average outpatient cost per year by averaging `average_total_payments` multiplied by `outpatient_services`. Group the data by `provider_id`, `provider_state`, `provider_city`, `provider_name`, and year.\r\n\r\n5. **Join Inpatient and Outpatient Data**\r\n   - **Merge Inpatient and Outpatient Data:** Perform a LEFT JOIN on the inpatient and outpatient datasets based on `provider_id`, `provider_state`, `provider_city`, `provider_name`, and year.\r\n\r\n6. **Format and Order Final Results**\r\n   - **Select and Format Fields:** Select relevant fields including `State`, `City`, `Provider_ID`, `Provider_Name`, year, and round the average inpatient and outpatient costs.\r\n   - **Order by Year:** Sort the final results by year for chronological presentation.\r\n\r\nThis plan ensures the correct identification of the top provider based on inpatient costs and retrieves comprehensive annual cost data for both inpatient and outpatient services for detailed analysis.",
        "special_function": [
            "mathematical-functions/ROUND"
        ]
    },
    {
        "instance_id": "bq129",
        "db": "bigquery-public-data.cms_medicare\nbigquery-public-data.census_bureau_usa",
        "question": "What are the top 10 ZIP Code regions with populations over 1000 that have the highest number of Medicare-certified MD providers per capita?",
        "external_knowledge": null,
        "plan": "What are the ten zip codes with highest number of physicians per population (based on Medicare reimbursement data)?\nThe Centers for Medicare and Medicaid Services public dataset provides information on services and procedures provided to Medicare beneficiaries by physicians and other healthcare professionals in 2012. This query analyzes the number of physicians in each zip code (as listed in the Medicare data) compared to underlying population in each zip code according to the 2010 census data. ZCTAs are used in the census data to approximate zip codes.",
        "special_function": [
            "mathematical-functions/ROUND",
            "string-functions/LENGTH",
            "string-functions/REGEXP_CONTAINS",
            "string-functions/SUBSTR",
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE",
            "conditional-functions/NULLIF"
        ]
    },
    {
        "instance_id": "bq032",
        "db": "bigquery-public-data.noaa_hurricanes",
        "question": "Can you provide the latitude of the final coordinates for the hurricane that traveled the second longest distance in the North Atlantic during 2020?",
        "external_knowledge": null,
        "plan": "1. Select hurricane data for the 2020 season located in the North Atlantic (NA).\n2. Obtain position change information for each hurricane based on the time of movement.\n3. Calculate the total distance traveled by each hurricane.\n4. Rank hurricanes based on their total travel distances and select the hurricane that ranks second.\n5. Output the coordinate changes for the movement of this hurricane\n6. Only retain the last coordinate of this hurricane",
        "special_function": [
            "geography-functions/ST_DISTANCE",
            "geography-functions/ST_GEOGPOINT",
            "geography-functions/ST_Y",
            "navigation-functions/LAG",
            "numbering-functions/DENSE_RANK"
        ]
    },
    {
        "instance_id": "bq032_1",
        "db": "bigquery-public-data.noaa_hurricanes",
        "question": "Please show information of the hurricane with the third longest total travel distance, including its travel coordinates, the cumulative travel distance at each point, and the maximum sustained wind speed at those times.",
        "external_knowledge": null,
        "plan": "1. **Filter Data**:\n   - Start with a dataset containing records of a specific event type for a particular year and region.\n   - Exclude entries that are not named.\n\n2. **Create Geometric Points**:\n   - For each record, create a geographic point from the given coordinates.\n\n3. **Calculate Distances**:\n   - For each event, calculate the distance between consecutive geographic points in kilometers.\n   - Use a window function to compute the distance between each point and the previous point, ordered by time.\n\n4. **Cumulative Distance Calculation**:\n   - For each event, calculate the cumulative distance traveled up to each point in time.\n   - Also, compute the total distance traveled by each event over its entire duration.\n\n5. **Rank Events**:\n   - Rank all events based on their total travel distance, with the longest distance receiving the highest rank.\n\n6. **Select Specific Rank**:\n   - Select the records for the event that has the third longest total travel distance.\n\n7. **Final Output**:\n   - From the selected event, extract and display the geographic points, cumulative distances at each point, and the maximum wind speed recorded at those points.\n   - Order the results by cumulative distance.",
        "special_function": [
            "geography-functions/ST_DISTANCE",
            "geography-functions/ST_GEOGPOINT",
            "navigation-functions/LAG",
            "numbering-functions/DENSE_RANK"
        ]
    },
    {
        "instance_id": "bq117",
        "db": "bigquery-public-data.noaa_historic_severe_storms",
        "question": "What is the total number of severe storm events that occurred in the most affected month over the past 15 years according to NOAA records, considering only the top 100 storm events with the highest property damage?",
        "temporal": "Yes",
        "external_knowledge": null,
        "plan": "1. **Define a Subquery for Base Information:**\n   - Create a temporary table to aggregate storm event data.\n   - Extract unique event identifiers and calculate the earliest occurrence time for each event.\n   - Format the month and year of the earliest occurrence into a string.\n   - Aggregate unique county names, state names, and event types, limiting each to a certain number of unique values.\n   - Sum the property damage values and convert the total to billions.\n\n2. **Filter Data for the Past 15 Years:**\n   - Restrict the data to the past 15 years by comparing the year of the event to the current year, using a dynamic range calculated from the current date.\n\n3. **Group and Sort Data:**\n   - Group the data by unique event identifiers.\n   - Sort the aggregated results by the total property damage in descending order.\n   - Limit the results to the top 100 events with the highest property damage.\n\n4. **Count Events by Month:**\n   - From the aggregated results, count the number of events that occurred in each month.\n\n5. **Determine the Most Affected Month:**\n   - Group the counted results by month.\n   - Sort the counts in descending order to identify the month with the highest number of severe storm events.\n   - Limit the results to the top month (the one with the highest count).\n\n6. **Return the Final Result:**\n   - Output the total number of severe storm events that occurred in the most affected month over the past 15 years.",
        "special_function": [
            "aggregate-functions/STRING_AGG",
            "conversion-functions/CAST",
            "date-functions/CURRENT_DATE",
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "json-functions/STRING",
            "string-functions/CONCAT",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "timestamp-functions/STRING"
        ]
    },
    {
        "instance_id": "bq071",
        "db": "bigquery-public-data.noaa_hurricanes\nbigquery-public-data.geo_us_boundaries",
        "question": "What are the top 10 zip codes of the areas in the United States that have been affected by the most named hurricanes?",
        "external_knowledge": null,
        "plan": "1. **Select Required Columns**: Begin by selecting the necessary columns which include the city, zip code, state, the count of distinct hurricane names, and a concatenated string of distinct hurricane names.\n\n2. **Join Two Data Sources**: Combine data from the zip codes dataset and the hurricanes dataset. This will allow you to link hurricanes to the zip codes they have affected.\n\n3. **Filter Data**: Use a spatial function to filter and ensure that only hurricanes whose coordinates fall within the geometric boundaries of the zip codes are considered. Additionally, exclude hurricanes that are not named.\n\n4. **Group Data**: Group the filtered data by zip code, city, and state. This allows for aggregation operations to be performed on each group.\n\n5. **Count Distinct Hurricanes**: For each group, count the number of distinct hurricanes that have affected that area.\n\n6. **Concatenate Hurricane Names**: Create a concatenated string of the names of the distinct hurricanes for each group.\n\n7. **Order and Limit Results**: Order the results by the count of distinct hurricanes in descending order to identify the areas most affected by named hurricanes. Limit the output to the top 10 zip codes.\n\n8. **Return Final Output**: Display the final output with columns for city, zip code, state, the count of hurricanes, and the concatenated hurricane names.",
        "special_function": [
            "aggregate-functions/STRING_AGG",
            "conversion-functions/CAST",
            "geography-functions/ST_GEOGPOINT",
            "geography-functions/ST_WITHIN",
            "json-functions/STRING",
            "string-functions/CONCAT",
            "timestamp-functions/STRING"
        ]
    },
    {
        "instance_id": "bq117_1",
        "db": "bigquery-public-data.noaa_historic_severe_storms\nbigquery-public-data.geo_us_boundaries.zip_codes",
        "question": "What are the top 5 zip codes of the areas in the United States that have experienced the most hail storm events in the past 10 years?",
        "temporal": "Yes",
        "external_knowledge": null,
        "plan": "What zip codes have experienced the most hail storms in the last 10 years?\nThis query combines the severe weather events dataset with the zip code boundary data  available as a BigQuery Public Dataset to group hail events by zip code over the last 10 years.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/CURRENT_DATE",
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "geography-functions/ST_WITHIN",
            "interval-functions/EXTRACT",
            "json-functions/STRING",
            "string-functions/CONCAT",
            "string-functions/LOWER",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "timestamp-functions/STRING"
        ]
    },
    {
        "instance_id": "bq356",
        "db": "bigquery-public-data.noaa_gsod",
        "question": "What is the number of weather stations where the valid temperature record days in 2019 reached 90% or more of the maximum number of recorded days, and have had tracking back to 1/1/2000 or before and through at least 6/30/2019?",
        "external_knowledge": null,
        "plan": "1. **Subquery to Count Valid Temperature Record Days by Station in 2019:**\n    - Create a subquery to count the number of distinct dates with valid temperature data for each station.\n    - Convert year, month, and day information into a date format.\n    - Filter out records with missing temperature data and invalid temperature values.\n    - Group the results by each weather station.\n\n2. **Subquery to Calculate Maximum Number of Valid Temperature Record Days in 2019:**\n    - Create another subquery to find the maximum number of valid temperature record days across all stations for the year 2019.\n\n3. **Main Query to Count Qualifying Weather Stations:**\n    - Select the main weather stations table.\n    - Perform an inner join with the subquery from step 1 to filter only those stations that have temperature data in 2019.\n    - Cross join with the subquery from step 2 to make the maximum number of valid temperature record days available for filtering.\n    - Apply additional filtering conditions:\n        - Include only stations that have been tracking data since at least January 1, 2000.\n        - Include only stations that have continued tracking data through at least June 30, 2019.\n        - Include only stations where the number of valid temperature record days in 2019 is at least 90% of the maximum number of valid temperature record days across all stations for 2019.\n\n4. **Count and Return the Number of Stations Meeting All Criteria:**\n    - Count the number of stations that meet all the specified conditions and return this count as the final result.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/DATE",
            "mathematical-functions/LEAST"
        ]
    },
    {
        "instance_id": "bq357",
        "db": "bigquery-public-data.noaa_icoads",
        "question": "What are the top 5 latitude and longitude coordinates and dates between 2005 and 2015 with the highest daily average wind speed, excluding records with missing wind speed values?",
        "external_knowledge": null,
        "plan": "1. **Data Aggregation Preparation**:\n   - Create a temporary table to store aggregated daily average values.\n   - Select the necessary date and location columns.\n   - Calculate the average value of the target variable for each unique combination of date and location.\n\n2. **Filtering by Date Range**:\n   - Ensure that only the records within the specified date range are considered for aggregation.\n\n3. **Grouping Data**:\n   - Group the data by date and location to facilitate the calculation of daily averages.\n\n4. **Calculate Daily Averages**:\n   - Compute the average value of the target variable for each group (combination of date and location).\n\n5. **Exclude Missing Values**:\n   - Filter out any records where the computed average is missing.\n\n6. **Sort and Limit Results**:\n   - Sort the resulting dataset by the calculated average in descending order.\n   - Limit the results to the top 5 records with the highest daily averages.\n\n7. **Final Selection**:\n   - Select the required columns from the temporary table to present the final output, including date, location, and the calculated averages.",
        "special_function": null
    },
    {
        "instance_id": "bq181",
        "db": "bigquery-public-data.noaa_gsod",
        "question": "How much percentage of weather stations recorded temperature data for at least 90% of the days in 2022?",
        "external_knowledge": null,
        "plan": "1. Calculate the total number of days in 2022 that it records the temperature data (not missing) for each station.\n2. Find out the total number of valid stations.\n3. Leverage the knowledge that 2022 has 365 days.\n4. Join the table with the stations table to find out the stations which records for at least 90% of days in 2022.\n5. Calculate the percentage of stations with over 90% records .",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/DATE"
        ]
    },
    {
        "instance_id": "bq045",
        "db": "bigquery-public-data.noaa_gsod",
        "question": "Which weather stations in Washington State had more than 150 rainy days in 2023 but fewer rainy days than in 2022?",
        "external_knowledge": null,
        "plan": "1. Extract data for each weather station for the years 2023 and 2022, focusing on entries that record precipitation levels.\n2. Filter these records to retain only the days with precipitation greater than zero as rainy days.\n3. Merge the records from 2023 and 2022, retaining only those stations where 2023 had more than 150 rainy days and less precipitation than in 2022.\n4. Query station information to obtain the names of these weather stations.",
        "special_function": [
            "aggregate-functions/ANY_VALUE"
        ]
    },
    {
        "instance_id": "bq290",
        "db": "bigquery-public-data.noaa_gsod",
        "question": "Can you calculate the difference in maximum temperature, minimum temperature, and average temperature between US and UK weather stations for each day in October 2023, excluding records with missing temperature values?",
        "external_knowledge": null,
        "plan": "1. **Filter Relevant Stations**:\n   - Identify and select weather stations located in the specified countries.\n\n2. **Join Station Data with Weather Data**:\n   - Combine the weather station data with the weather observations for the specified year.\n   - Filter the combined data to include only the records within the specified date range.\n   - Exclude records with missing temperature values.\n\n3. **Calculate Daily Metrics for US**:\n   - For the filtered data, compute the average, minimum, and maximum temperatures for each day in the specified date range for stations in one of the specified countries.\n   - Group the results by date.\n\n4. **Calculate Daily Metrics for UK**:\n   - Repeat the previous step for the other specified country.\n\n5. **Calculate Temperature Differences**:\n   - For each day, compute the difference in maximum, minimum, and average temperatures between the two countries.\n   - Join the daily metrics from both countries on the date to perform these calculations.\n\n6. **Output Results**:\n   - Select the computed temperature differences and the corresponding dates.\n   - Order the results by date for a chronological output.",
        "special_function": [
            "date-functions/DATE"
        ]
    },
    {
        "instance_id": "bq031",
        "db": "bigquery-public-data.noaa_gsod",
        "question": "Show me the daily weather data (temperature, precipitation, and wind speed) in Rochester for the first season of year 2019, converted to Celsius, centimeters, and meters per second, respectively. Also, include the moving averages (window size = 8) and the differences between the moving averages for up to 8 days prior (all values rounded to one decimal place, sorted by date in ascending order, and records starting from 2019-01-09).",
        "external_knowledge": null,
        "plan": "1. Data Transformation and Filtering:\n   - Convert the date components into a proper date format.\n   - Transform temperature from Fahrenheit to Celsius, precipitation from inches to centimeters, and wind speed from knots to meters per second.\n   - Filter the data to include only the records for the specified location and year.\n\n2. Calculation of Moving Averages:\n   - Calculate the moving averages for temperature, precipitation, and wind speed using a window size of 8 days.\n\n3. Lagging the Moving Averages:\n   - Create lagged versions of the moving averages for up to 8 days prior.\n\n4. Calculating Differences:\n   - Compute the differences between the current moving averages and their lagged versions for up to 8 days.\n\n5. Final Selection and Sorting:\n   - Select the relevant columns, round the values to one decimal place, ensure the lagged values are not null, and sort the results by date in ascending order.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/DATE",
            "mathematical-functions/ROUND",
            "navigation-functions/LAG"
        ]
    },
    {
        "instance_id": "bq291",
        "db": "spider2-public-data.noaa_global_forecast_system",
        "question": "What is the daily weather forecast summary, including temperature stats (max, min and average), precipitation, cloud cover, snow and rain, for the specified location (latitude 17.5, longitude 23.25) and on November 28, 2021?",
        "external_knowledge": null,
        "plan": "1. **Define Subquery for Daily Forecasts:**\n   - Create a subquery to gather relevant weather data for the specified location and date.\n   - Convert forecast times to local dates by adding 1 hour and extracting the date.\n\n2. **Calculate Temperature Statistics:**\n   - Compute the maximum temperature for the day by selecting the highest value of temperature data.\n   - Compute the minimum temperature for the day by selecting the lowest value of temperature data.\n   - Compute the average temperature for the day by averaging the temperature data.\n\n3. **Calculate Precipitation:**\n   - Sum up all the precipitation data to get the total precipitation for the day.\n\n4. **Calculate Cloud Cover:**\n   - Calculate the average cloud cover during daytime hours (10:00 AM to 5:00 PM).\n\n5. **Calculate Snow and Rain:**\n   - Calculate the total snow by summing up precipitation if the average temperature is below freezing.\n   - Calculate the total rain by summing up precipitation if the average temperature is above or equal to freezing.\n\n6. **Filter and Group Data:**\n   - Filter the data to include only the forecasts created on the specified date.\n   - Ensure the data is for the specified geographical location within a 5 km radius.\n   - Group the data by creation time and local forecast date.\n\n7. **Select Final Output:**\n   - Select the relevant columns from the subquery to be included in the final output.\n   - Order the results by creation time and local forecast date.\n\n8. **Return Results:**\n   - Return the daily weather forecast summary including temperature statistics, precipitation, cloud cover, snow, and rain for the specified location and date.",
        "special_function": [
            "date-functions/DATE",
            "date-functions/DATE_ADD",
            "datetime-functions/DATETIME_ADD",
            "geography-functions/ST_DWITHIN",
            "geography-functions/ST_GEOGPOINT",
            "time-functions/TIME",
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE",
            "conditional-functions/IF",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq208",
        "db": "bigquery-public-data.new_york\nbigquery-public-data.noaa_gsod",
        "question": "Can you provide weather stations within a 20-mile radius of Chappaqua, New York (Latitude: 41.197, Longitude: -73.764), and tell me the number of valid temperature observations they have recorded from 2011 to 2020?",
        "external_knowledge": null,
        "plan": "1. **Define Location and Home**:\n   - Create a temporary reference for the specific location (latitude and longitude) and assign a name to it.\n\n2. **Fetch and Enhance Weather Stations Data**:\n   - Retrieve data about weather stations, adding a geographical point (latitude and longitude) for each station.\n\n3. **Identify Nearby Stations**:\n   - Calculate the distance between the specified location and each weather station.\n   - Filter out stations that are within a 20-mile radius of the specified location.\n   - Group these stations by their proximity to the specified location.\n\n4. **Extract Closest Station Details**:\n   - Flatten the grouped data to get detailed information about each nearby station.\n\n5. **Count Valid Temperature Observations**:\n   - Join the detailed weather station information with temperature observation data.\n   - Filter out invalid temperature readings.\n   - Restrict the data to observations recorded between the years 2011 and 2020.\n   - Count the number of valid temperature observations for each station within the specified radius.\n   - Group the results by station details and order them by proximity.\n\nThis plan ensures that the query retrieves the required weather stations within the given radius and accurately counts their valid temperature observations over the specified period.",
        "special_function": [
            "aggregate-functions/ARRAY_AGG",
            "geography-functions/ST_ASTEXT",
            "geography-functions/ST_DISTANCE",
            "geography-functions/ST_DWITHIN",
            "geography-functions/ST_GEOGPOINT",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq017",
        "db": "bigquery-public-data.geo_openstreetmap",
        "question": "What are the five longest types of highways within the multipolygon boundary of Japan (as defined by Wikidata ID 'Q17') by total length?",
        "external_knowledge": null,
        "plan": "1.Select records identified by Wikidata ID Q17 to capture the geographic area of Japan, retrieving geometries of the 'multipolygons' feature type.\n2.Choose records of the 'lines' feature type, which typically represent highways and other linear geographic features, ensuring that the highway data's geometry intersects with the boundaries of Japan.\n3.Extract the type of each highway and calculate the length of these highways.\n4.Group the results by highway type and then order them by the total length of the highways in descending order.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "geography-functions/ST_DWITHIN",
            "geography-functions/ST_LENGTH",
            "interval-functions/EXTRACT",
            "string-functions/FORMAT",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq131",
        "db": "bigquery-public-data.geo_openstreetmap",
        "question": "What is the number of bus stops for the bus network with the most stops within the multipolygon boundary of San Francisco (as defined by Wikidata ID 'Q62')?",
        "external_knowledge": null,
        "plan": "1. Retrieve the 'multipolygons' geometry for the area identified by Wikidata ID Q62, setting the boundaries for the query.\n2. Choose point features tagged as 'highway' with 'bus_stop' values, ensuring they are within the defined area.\n3. Extract the bus network information from the 'network' key for each stop, and count the number of stops per network.\n4. Group the results by bus network and order them by the descending count of stops to identify the network with the most stops.",
        "special_function": [
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "geography-functions/ST_DWITHIN",
            "interval-functions/EXTRACT",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq106",
        "db": "bigquery-public-data.geo_openstreetmap\nspider2-public-data.noaa_global_forecast_system",
        "question": "For the two-week forecast made on November 28th, 2021, how much did temperatures in Sudan deviate from the predicted value?",
        "external_knowledge": null,
        "plan": "1. Define the Boundary for Sudan:\n   - Create a Common Table Expression (CTE) to select geographic boundary data for Sudan.\n   - Filter the `planet_layers` table to include only rows where `layer_class` is 'boundary' and `layer_name` is 'national'.\n   - Use an `EXISTS` clause to ensure the boundary is for Sudan by checking the `ISO3166-1` tag in `all_tags`.\n\n2. Select Relevant Forecast Data:\n   - Create another CTE to select Global Forecast System (GFS) data from the `NOAA_GFS0P25` table.\n   - Filter the GFS data to include only those records created on '2021-11-28T00:00:00'.\n   - Ensure the selected forecast points are within the geographic boundary of Sudan using `ST_WITHIN`.\n\n3. Calculate Predicted Temperatures:\n   - Create a CTE named to calculate average temperatures predicted for each day within the two-week period.\n   - Join with the `forecast` array, and filter the forecast to include only daily data (`MOD(hours, 24) = 0`) within the first 14 days (`hours / 24 <= 14`).\n   - Group by `creation_time` and `time` to compute the average daily temperature.\n\n4. Fetch Observed Temperatures:\n   - Create a CTE named to compare predicted temperatures against observed temperatures.\n   - Join the predicted temperatures with the GFS data (`NOAA_GFS0P25` table) to find actual observations at the predicted times.\n   - Use `ST_WITHIN` to ensure observed points are within the Sudan boundary.\n   - Group the results to calculate the average observed temperature for each predicted time.\n\n5. Calculate Prediction Error and Return Query Execution:\n   - Select the deviation (error) between observed and predicted temperatures by subtraction.\n   - Sort the results by observed time.",
        "special_function": [
            "geography-functions/ST_WITHIN",
            "mathematical-functions/MOD",
            "time-functions/TIME",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq293",
        "db": "bigquery-public-data.geo_us_boundaries\nbigquery-public-data.new_york",
        "question": "What were the top 5 busiest pickup times and locations (by ZIP code) for yellow taxi rides in New York City on January 1, 2015? Additionally, provide detailed metrics for each of these top 5 records, including the count of rides, hourly, daily, and weekly lagged counts, as well as 14-day and 21-day average and standard deviation of ride counts.",
        "external_knowledge": null,
        "plan": "1. **Define `base_data` CTE:**\r\n   - **Select Data:** Fetch data from the `bigquery-public-data.new_york.tlc_yellow_trips_2015` table for trips on '2015-01-01' where `pickup_latitude` is between -90 and 90.\r\n   - **Filter and Join:** Join the filtered taxi data (`nyc_taxi`) with the `bigquery-public-data.geo_us_boundaries.zip_codes` table for New York state (`state_code = 'NY'`), using spatial containment (`ST_CONTAINS`) to match pickups to zip codes, excluding the `zip_code_geom` field from the `gis` table.\r\n\r\n2. **Define `distinct_datetime` CTE:**\r\n   - **Extract Unique Hours:** Select distinct `pickup_datetime` truncated to the hour from `base_data`.\r\n\r\n3. **Define `distinct_zip_code` CTE:**\r\n   - **Extract Unique Zip Codes:** Select distinct `zip_code` from `base_data`.\r\n\r\n4. **Define `zip_code_datetime_join` CTE:**\r\n   - **Cartesian Product:** Perform a CROSS JOIN between `distinct_zip_code` and `distinct_datetime` to create combinations of all zip codes and hours.\r\n   - **Extract Date Parts:** Add columns to extract month, day, weekday, hour, and a flag (`is_weekend`) indicating if the day is a weekend.\r\n\r\n5. **Define `agg_data` CTE:**\r\n   - **Aggregate Data:** Aggregate `base_data` by `zip_code` and `pickup_hour`, counting the number of pickups per hour per zip code.\r\n\r\n6. **Define `join_output` CTE:**\r\n   - **Left Join Aggregated Data:** Perform a LEFT JOIN between `zip_code_datetime_join` and `agg_data` to include pickup counts (`cnt`), filling missing counts with 0 using `IFNULL`.\r\n\r\n7. **Define `final_output` CTE:**\r\n   - **Calculate Lag and Rolling Stats:** Compute lag values and rolling averages/std deviations over different time windows (1 hour, 1 day, 7 days, 14 days, 21 days) for each `zip_code` and `pickup_hour`.\r\n\r\n8. **Final Selection and Ordering:**\r\n   - **Select and Limit:** Select all columns from `final_output`, order by `cnt` in descending order, and limit the result to the top 5 records.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/DATE",
            "date-functions/EXTRACT",
            "datetime-functions/DATETIME_TRUNC",
            "datetime-functions/EXTRACT",
            "datetime-functions/FORMAT_DATETIME",
            "geography-functions/ST_CONTAINS",
            "geography-functions/ST_GEOGPOINT",
            "interval-functions/EXTRACT",
            "mathematical-functions/ROUND",
            "navigation-functions/LAG",
            "statistical-aggregate-functions/STDDEV",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE",
            "conditional-functions/IFNULL"
        ]
    },
    {
        "instance_id": "bq250",
        "db": "bigquery-public-data.geo_openstreetmap\nbigquery-public-data.worldpop",
        "question": "What is the total population living on the geography grid which is the farthest from any hospital in Singapore, based on the most recent population data before 2023? Note that geographic grids and distances are calculated based on geospatial data and GIS related functions.",
        "external_knowledge": "https://github.com/xlang-ai/Spider2-C/blob/main/Spider2-SQL/external_documents/OpenStreetMap_data_in_layered_GIS_format.md",
        "plan": "1. Simply define a single value 'Singapore' as the country of interest.\n2. Find the most recent date when the population data was last updated for Singapore.\n3. Calculate the total population of Singapore and create a bounding box that encompasses the entire country.\n4. Select the geometries of hospitals and doctors that are within the bounding box of Singapore.\n5. Calculate the minimum distance between each populated grid cell and the nearest hospital or doctor.\n6. Aggregate the total population of all grid cells and return the total population that lives farthest away from hospitals and doctors in Singapore. \n",
        "special_function": [
            "geography-functions/ST_CENTROID_AGG",
            "geography-functions/ST_CONVEXHULL",
            "geography-functions/ST_DISTANCE",
            "geography-functions/ST_GEOGPOINT",
            "geography-functions/ST_INTERSECTS",
            "geography-functions/ST_UNION_AGG"
        ]
    },
    {
        "instance_id": "bq056",
        "db": "bigquery-public-data.geo_openstreetmap\nbigquery-public-data.geo_us_boundaries",
        "question": "How many different motorway road pairs are there in Minnesota that overlap each other but do not share nodes and do not have a bridge?",
        "external_knowledge": null,
        "plan": "1. Filter by State and Road Type: Identify the specified state and road type from the geographical boundaries and road data tables.\n\n2. Select Relevant Roads: Extract unique identifiers for roads that match the specified type (e.g., motorway) from the road data.\n\n3. Identify Roads Within State: Match the roads with the geographical boundary of the specified state to ensure only roads within the state are considered.\n\n4. Find Overlapping Roads: Determine pairs of roads that geographically overlap each other but do not share nodes.\n\n5. Exclude Roads with Bridges: Filter out road pairs where either road has a bridge attribute.\n\n6. Count Overlapping Pairs: Count the number of unique road pairs that overlap but do not share nodes and do not have a bridge.",
        "special_function": [
            "geography-functions/ST_CONTAINS",
            "geography-functions/ST_INTERSECTS",
            "json-functions/STRING",
            "mathematical-functions/GREATEST",
            "mathematical-functions/LEAST",
            "string-functions/LOWER",
            "timestamp-functions/STRING",
            "other-functions/DECLARE",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq184",
        "db": "bigquery-public-data.crypto_ethereum",
        "question": "I want to compute and compare the cumulative count of Ethereum smart contracts created by users versus created by other contracts. Please list out the daily cumulative tallies in August 2021.",
        "external_knowledge": null,
        "plan": "1. **Filter Data for User-Created Contracts:**\n   - Extract records where the entity type is contract creation and the creator is a user (not another contract).\n   - Group these records by date and count the number of creations per day.\n   \n2. **Calculate Cumulative Sum for User-Created Contracts:**\n   - Compute the running total of contract creations by users, ordered by date.\n   - Determine the next date for each record to help with calendar alignment.\n\n3. **Generate Calendar for August 2021:**\n   - Create a list of all dates in August 2021 to ensure all dates are covered in the final output, even if no contracts were created on some days.\n\n4. **Align User-Created Contracts with Calendar:**\n   - Join the cumulative sum data with the calendar dates to ensure there is a record for each day in August 2021.\n   - Ensure the cumulative sum is carried forward to the next date where appropriate.\n\n5. **Filter Data for Contract-Created Contracts:**\n   - Extract records where the entity type is contract creation and the creator is another contract.\n   - Group these records by date and count the number of creations per day.\n\n6. **Calculate Cumulative Sum for Contract-Created Contracts:**\n   - Compute the running total of contract creations by contracts, ordered by date.\n   - Determine the next date for each record to help with calendar alignment.\n\n7. **Generate Calendar for August 2021 (Again):**\n   - Create a list of all dates in August 2021 to ensure all dates are covered in the final output, even if no contracts were created on some days (separate calendar for the second cumulative sum).\n\n8. **Align Contract-Created Contracts with Calendar:**\n   - Join the cumulative sum data with the calendar dates to ensure there is a record for each day in August 2021.\n   - Ensure the cumulative sum is carried forward to the next date where appropriate.\n\n9. **Combine and Compare Results:**\n   - Join the two cumulative sum datasets (user-created and contract-created) on the date to get a consolidated view.\n   - Select the date, cumulative sum of user-created contracts, and cumulative sum of contract-created contracts for the final output.\n\n10. **Order Final Output:**\n    - Ensure the final result is ordered by date for clear comparison.",
        "special_function": [
            "array-functions/GENERATE_DATE_ARRAY",
            "date-functions/DATE",
            "navigation-functions/LEAD",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq195",
        "db": "spider2-public-data.crypto_ethereum",
        "question": "What are the top 10 Ethereum addresses by balance, considering both value transactions and gas fees, before September 1, 2021?",
        "external_knowledge": null,
        "plan": "1. **Define the Value Table:**\n   - Create a temporary table to aggregate all relevant balance changes for addresses.\n   \n2. **Select Incoming Transactions:**\n   - Extract all transactions where the address is the recipient and the transaction was successful before the specified date.\n   - Include only specific types of calls (exclude 'delegatecall', 'callcode', 'staticcall') or if the call type is null.\n\n3. **Select Outgoing Transactions:**\n   - Extract all transactions where the address is the sender and the transaction was successful before the specified date.\n   - Negate the transaction value to represent outgoing funds.\n   - Similar to incoming transactions, exclude certain call types or if the call type is null.\n\n4. **Calculate Miner Rewards:**\n   - Sum the gas fees received by miners for all blocks mined before the specified date.\n   - Group the results by miner address to aggregate total rewards.\n\n5. **Calculate Gas Fees Spent:**\n   - Extract all transactions where the address is the sender and calculate the total gas fees spent.\n   - Negate the value to represent the outgoing gas fees.\n\n6. **Aggregate All Values:**\n   - Combine the results of the above steps into the temporary table, ensuring all values are correctly signed (positive for incoming, negative for outgoing).\n\n7. **Calculate Final Balances:**\n   - Sum all values for each address from the temporary table.\n   - Convert the summed value from the base unit to the standard unit of measurement.\n\n8. **Order and Limit Results:**\n   - Sort the addresses by their calculated balance in descending order.\n   - Limit the results to the top 10 addresses.\n\nBy following these steps, the query identifies the top 10 Ethereum addresses by balance before the specified date, considering both transaction values and gas fees.",
        "special_function": [
            "conversion-functions/CAST",
            "mathematical-functions/FLOOR",
            "mathematical-functions/POWER"
        ]
    },
    {
        "instance_id": "bq256",
        "db": "spider2-public-data.crypto_ethereum",
        "question": "What is the balance of the Ethereum address that initiated the highest number of transactions before September 1, 2021?",
        "external_knowledge": null,
        "plan": "1. Gather transaction details like addresses, values, and gas information for Ethereum transactions up to September 1, 2021.\n2. Calculate the net balance for each address by aggregating incoming and outgoing transaction values.\n3. Count the number of transactions received by each address.\n4. Count the number of transactions sent by each address.\n5. Calculate the balance for senders with the most transactions and return.\n",
        "special_function": [
            "conversion-functions/CAST",
            "mathematical-functions/POWER"
        ]
    },
    {
        "instance_id": "bq186",
        "db": "bigquery-public-data.san_francisco.bikeshare_trips",
        "question": "Please help me calculate the first, last, highest, and lowest bike trip durations in minutes for each month.",
        "external_knowledge": null,
        "plan": "1. **Create a Temporary Dataset**:\n    - Generate a temporary dataset where each record is associated with a date string representing the year and month of the start date of the trip.\n    - This dataset includes all original columns plus the newly created date string.\n\n2. **Calculate Trip Durations**:\n    - From the temporary dataset, for each unique month, calculate:\n        - The first trip duration.\n        - The last trip duration.\n        - The highest trip duration.\n        - The lowest trip duration.\n    - Convert these durations from seconds to minutes.\n\n3. **Retrieve and Format Results**:\n    - Select the date string (representing the month) and the calculated trip durations (first, last, highest, and lowest) from the results of the previous step.\n    - Ensure the results are ordered by the date string to maintain chronological order.\n\n4. **Final Output**:\n    - Output the date string and the calculated trip durations (in minutes) for each month, ensuring that the data is grouped and ordered by the date string.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/DATE",
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "json-functions/STRING",
            "navigation-functions/FIRST_VALUE",
            "navigation-functions/LAST_VALUE",
            "string-functions/CONCAT",
            "string-functions/LPAD",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "timestamp-functions/STRING"
        ]
    },
    {
        "instance_id": "bq339",
        "db": "bigquery-public-data.san_francisco_bikeshare",
        "question": "Which month in 2017 had the largest absolute difference between cumulative bike usage minutes for customers and subscribers?",
        "external_knowledge": null,
        "plan": "1. **Create a Subquery for Monthly Totals**:\n   - Calculate the total usage minutes for each user type (e.g., type A and type B) for each month in the specified year.\n   - Group the results by month to get monthly totals for each user type.\n\n2. **Calculate Cumulative Totals**:\n   - Using the monthly totals, compute the cumulative sum of usage minutes for each user type up to each month.\n   - This involves summing the monthly totals in an ordered manner, from the beginning of the year to the end of each month.\n\n3. **Calculate Absolute Differences**:\n   - Determine the absolute difference between the cumulative totals of the two user types for each month.\n   - This provides a measure of how the cumulative usage minutes differ between the two user types at the end of each month.\n\n4. **Identify the Month with the Largest Difference**:\n   - Sort the months based on the absolute difference calculated in the previous step, in descending order.\n   - Select the month with the highest absolute difference.\n\nBy following these steps, the query identifies the month in the specified year that had the largest absolute difference in cumulative bike usage minutes between the two user types.",
        "special_function": [
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "mathematical-functions/ABS",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "conditional-functions/CASE"
        ]
    },
    {
        "instance_id": "bq059",
        "db": "bigquery-public-data.san_francisco_bikeshare",
        "question": "What is the highest average speed (rounded to 1 decimal, in metric m/s) for bike trips in Berkeley with trip distance greater than 1000 meters?",
        "external_knowledge": null,
        "plan": "1. Identify Relevant Locations: Select station identifiers for bike stations located in a specific region (Berkeley) by filtering based on the region's name.\n\n2. Calculate Distances and Speeds: For trips starting and ending at the identified stations, calculate the trip distance and the average speed. Ensure the coordinates for start and end stations are available.\n\n3. Filter Trips: Only include trips that meet the distance requirement (greater than 1000 meters) and start/end station restriction (within the region Berkeley).\n\n4. Find Maximum Speed: From the filtered trips, determine the highest average speed, rounded to one decimal place, and return this value.",
        "special_function": [
            "conversion-functions/CAST",
            "geography-functions/ST_DISTANCE",
            "json-functions/STRING",
            "mathematical-functions/ROUND",
            "timestamp-functions/STRING"
        ]
    },
    {
        "instance_id": "bq006",
        "db": "bigquery-public-data.austin_incidents",
        "question": "What is the date with the second highest Z-score for daily counts of 'PUBLIC INTOXICATION' incidents in Austin for the year 2016? List the date in the format of '2016-xx-xx'.",
        "external_knowledge": null,
        "plan": "Analyze daily occurrences of public intoxication incidents in Austin for the year 2016. \nCalculate the total number of incidents per day and compute the Z-score for each day's incidents to identify days with significantly higher or lower incident counts. \nThe output should include the date, total number of incidents, and the Z-score.",
        "special_function": [
            "date-functions/DATE",
            "mathematical-functions/ROUND",
            "statistical-aggregate-functions/STDDEV"
        ]
    },
    {
        "instance_id": "bq187",
        "db": "bigquery-public-data.ethereum_blockchain",
        "question": "What is the total circulating supply balances of the 'BNB' token for all addresses (excluding the zero address), based on the amount they have received (converted by dividing by 10^18) minus the amount they have sent?",
        "external_knowledge": null,
        "plan": "1. **Identify the Token:** Select the address of the specified token from the token details table.\n   \n2. **Calculate Received Amounts:**\n   - Filter transactions where the token matches the specified token.\n   - Exclude transactions to the zero address.\n   - Sum the received amounts for each address, converting the values to a standard unit.\n\n3. **Calculate Sent Amounts:**\n   - Filter transactions where the token matches the specified token.\n   - Exclude transactions from the zero address.\n   - Sum the sent amounts for each address, converting the values to a standard unit.\n\n4. **Compute Balances:**\n   - Combine the received and sent amounts for each address.\n   - Subtract the total sent amounts from the total received amounts to determine the balance for each address.\n\n5. **Aggregate Total Circulating Supply:**\n   - Sum the balances of all addresses to compute the total circulating supply of the token.",
        "special_function": [
            "conversion-functions/CAST",
            "mathematical-functions/POWER",
            "conditional-functions/COALESCE"
        ]
    },
    {
        "instance_id": "bq014",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "Can you help me figure out the revenue for the product category that has the highest number of customers making a purchase in their first non-cancelled and non-returned order?",
        "temporal": "Yes",
        "external_knowledge": null,
        "plan": "1. Get the first order of each user, excluding the cancelled and returned orders. (from 'orders' table)\n2. Calculate the total revenue and distinct user count for each product category. (combine the 'orders' 'order_items' and 'products' tables)\n3. Select the top category with the most user count.\n4. Based on the top category, get its revenue.",
        "special_function": [
            "numbering-functions/ROW_NUMBER"
        ]
    },
    {
        "instance_id": "bq188",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "What is the average time in minutes that users spend per visit on the product category with the highest total quantity purchased?",
        "temporal": "Yes",
        "external_knowledge": null,
        "plan": "1. **Create an Initial Dataset:**\n   - Extract event details including timestamps and session information.\n   - Identify events related to a specific type by transforming a specific URI component into an identifier.\n   - Calculate the timestamp for the next event in the same session.\n\n2. **Aggregate Purchase Data:**\n   - Determine the total number of times products in various categories have been purchased.\n   - Group this data by category.\n\n3. **Calculate Visit Statistics:**\n   - Compute visit details for each category by joining the initial dataset with product data.\n   - Count the number of visits for each category.\n   - Calculate the average time spent per visit by determining the time difference between consecutive events and converting it to minutes.\n   - Include the total quantity of purchases for each category from the aggregated purchase data.\n   - Filter out irrelevant events to ensure only meaningful data is included.\n\n4. **Determine the Desired Metric:**\n   - Select the average time spent per visit for the category with the highest total quantity purchased.\n   - Sort the results based on the total quantity purchased in descending order.\n   - Limit the results to get the top category.\n\n5. **Output the Result:**\n   - Convert the average time spent per visit to a string format for the final output.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/DATE_DIFF",
            "json-functions/STRING",
            "mathematical-functions/ROUND",
            "navigation-functions/LEAD",
            "string-functions/REPLACE",
            "timestamp-functions/STRING",
            "conditional-functions/CASE"
        ]
    },
    {
        "instance_id": "bq258",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "Can you provide a report that shows, for each product category by month and year prior to 2023, the percentage growth in revenue compared to the previous month, the percentage growth in orders compared to the previous month, the total cost of products sold, the total profit earned, and the profit to cost ratio? ",
        "external_knowledge": null,
        "plan": "1. Figure out metrics like Total Purchase Value (TPV) and Total Number of Orders (TPO) per month and product category.\n2. Get lagged values of TPV and TPO for each product category and compare with the current month's values.\n3. Calculates targeted metrics through the lagged values and latest values of TPV and TPO.\n",
        "special_function": [
            "date-functions/FORMAT_DATE",
            "mathematical-functions/ROUND",
            "navigation-functions/LAG",
            "conditional-functions/NULLIF"
        ]
    },
    {
        "instance_id": "bq259",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "Can you provide the percentage of users who made a purchase in the first, second, and third months after their initial purchase, organized by the month of their first purchase, using data up until the end of 2023?",
        "external_knowledge": null,
        "plan": "1. Determine the cohort date and index based on the time difference between the creation date and the user's first purchase date.\n2. Aggregate the total number of unique users for each cohort date and purchase index.\n3. Summarize the total number of users at each purchase index (0, 1, 2, 3) for every cohort date.\n4. Calculate the percentage distribution of users at each purchase index level relative to the initial cohort size for each cohort date.\n",
        "special_function": [
            "date-functions/EXTRACT",
            "date-functions/FORMAT_DATE",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "timestamp-functions/TIMESTAMP",
            "conditional-functions/CASE"
        ]
    },
    {
        "instance_id": "bq189",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "What is the average monthly revenue growth rate for the product category with the highest average monthly order growth rate based on completed orders?",
        "temporal": "Yes",
        "external_knowledge": null,
        "plan": "1. Calculate the total sale prices and total order amount (TPV) for each product category (TPO) every month.\n2. Get the TPV and TPO in the previous month as the 'Lagged_TPV' and 'Lagged_TPO'.\n3. Calculate the revenue growth rate and the order growth rate for each product monthly.\n4. Find out the product category with the max average order growth rate.\n5. Calculate the average revenue growth rate for that product category.",
        "special_function": [
            "date-functions/FORMAT_DATE",
            "mathematical-functions/ROUND",
            "navigation-functions/LAG",
            "conditional-functions/NULLIF"
        ]
    },
    {
        "instance_id": "bq260",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "Find the total number of youngest and oldest users separately for each gender in the e-commerce platform created from January 1, 2019, to April 30, 2022.",
        "external_knowledge": null,
        "plan": "1. Filter user data within the specified date range.\n2. Determine the youngest and oldest ages for each gender group.\n3. Identify users who are the youngest and oldest within their respective gender groups based on the age comparison.\n4. Count the number of users classified as the youngest and oldest within their gender groups.\n",
        "special_function": null
    },
    {
        "instance_id": "bq261",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "What is the total cost and profit of products whose profit rank first per month sorted chronologically? Only consider data before 2024.",
        "external_knowledge": null,
        "plan": "1. Calculate sales information for products, including the cost and profit.\n2. Assign a ranking to products within each month based on profit.\n3. Select and return the cost and profit figures for the top-ranking product for each month, sorting the results chronologically by month-year.\n",
        "special_function": [
            "numbering-functions/RANK",
            "timestamp-functions/FORMAT_TIMESTAMP",
            "timestamp-functions/TIMESTAMP"
        ]
    },
    {
        "instance_id": "bq262",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "Help me generate a monthly analysis report on e-commerce sales in the second half of 2019, which should contain the total sum of order count/revenue/profit as well as their growth rates for each product category monthly. Please sort the results by months (e.g., 2019-07) and product categories in ascending order.",
        "external_knowledge": null,
        "plan": "1. Filter and Aggregate Orders Data:\n   - Objective: Gather monthly order data for each product.\n   - Action: Create a CTE `orders_data` to:\n     - Extract the year-month from `created_at` timestamp in the `orders` table.\n     - Count the total orders and sum the sales price for each product per month.\n     - Filter orders within the months from 2019-06 to 2019-12.\n\n2. Fetch Product Category and Cost:\n   - Objective: Associate each product with its category and cost.\n   - Action: Create a CTE `product_data` to:\n     - Select product ID, category, and cost from the `products` table.\n\n3. Calculate Monthly Metrics:\n   - Objective: Compute monthly order count, total revenue, and total profit for each product category.\n   - Action: Create a CTE `monthly_metrics` to:\n     - Join `orders_data` with `product_data` on product ID.\n     - Aggregate data by month and product category.\n     - Calculate total orders, total revenue, and total profit (revenue minus cost of goods sold).\n\n4. Calculate Growth Rates:\n   - Objective: Determine month-over-month growth rates for order count, revenue, and profit.\n   - Action: Create a CTE `growth_metrics` to:\n     - Use window functions (`LAG`) to calculate the previous month's values for each metric within the same product category.\n     - Compute growth rates for orders, revenue, and profit as percentages.\n\n5. Generate Final Report:\n   - Objective: Present the monthly analysis report with growth rates.\n   - Action: Select all columns from `growth_metrics` except the month `2019-06`.\n     - Order the result by month and product category for organized viewing.",
        "special_function": [
            "navigation-functions/LAG",
            "timestamp-functions/FORMAT_TIMESTAMP",
            "timestamp-functions/TIMESTAMP"
        ]
    },
    {
        "instance_id": "bq190",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "What is the count of the youngest and oldest users respectively, broken down by gender from January 2019 to April 2022?",
        "external_knowledge": null,
        "plan": "1. **Determine Age Ranges**:\n   - Create two subsets to find the minimum and maximum ages for each gender within the specified date range.\n\n2. **Identify Users with Extreme Ages**:\n   - For each gender, select users whose ages match the previously identified minimum or maximum ages within the specified date range.\n\n3. **Combine Users**:\n   - Combine the users from both genders into a single set, ensuring that only users with the extreme ages (youngest and oldest) are included.\n\n4. **Tag Users**:\n   - Add a tag to each user indicating whether they are in the 'Youngest' or 'Oldest' age group based on their age.\n\n5. **Count Users by Group**:\n   - Group the tagged users by gender and tag, then count the number of users in each group.\n\n6. **Output the Results**:\n   - Select and order the results by gender and tag to present a clear summary of the counts for each group.",
        "special_function": [
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE"
        ]
    },
    {
        "instance_id": "bq263",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "Can you provide a report showing the total purchase value, total cost, total number of orders, total profit, and profit-to-cost ratio for product category \u2018Sleep & Lounge\u2019 each month in 2023? Make sure to only include completed orders.",
        "external_knowledge": null,
        "plan": "1. Consolidate data from the order items, orders, and products tables\n2. Computes key sales metrics including Total Purchase Value (TPV), total cost, Total Number of Orders (TPO), total profit, and Profit-to-Cost Ratio per month.\n3. Sort by month and return the result.\n",
        "special_function": [
            "date-functions/FORMAT_DATE",
            "timestamp-functions/TIMESTAMP"
        ]
    },
    {
        "instance_id": "bq264",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "Identify the difference in the number of the oldest and youngest users registered between January 1, 2019, and April 30, 2022, from our e-commerce platform data.",
        "external_knowledge": null,
        "plan": "1. Select the youngest users in terms of age for each gender within the specified date range.\n2. Identify the oldest users for each gender.\n3. Calculate the difference in the count of the oldest and youngest users.",
        "special_function": [
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE"
        ]
    },
    {
        "instance_id": "bq197",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "What are the top-selling products by sales volume and revenue for June 2024 and each month before, considering only completed orders?",
        "temporal": "Yes",
        "external_knowledge": null,
        "plan": "1. **Data Aggregation for Each Month**:\n    - **Extract and Format Data**: For each record, extract the product details and the order details, including the timestamp of the order, and format the timestamp to year and month.\n    - **Filter Data**: Consider only the orders that are marked as completed and occurred before July 2024.\n    - **Aggregate Data**: Group the data by product details and month to calculate the total number of sales and the total revenue for each product within each month.\n\n2. **Filter Non-relevant Data**:\n    - **Ensure Valid Data**: Ensure that the month, total revenue, and product brand are not null to maintain the integrity of the data.\n\n3. **Identify Top-Selling Products**:\n    - **Rank Products**: For each month, assign a rank to each product based on the total number of sales, with ties broken by total revenue.\n    - **Select Top Product**: Select the product with the highest rank (i.e., the top-selling product) for each month.\n\n4. **Final Output**:\n    - **Organize and Format**: Retrieve the month, product details, total sales, and total revenue for the top-selling product of each month.\n    - **Order Results**: Order the final results in ascending order of the month to provide a chronological view of the top-selling products over the specified period.",
        "special_function": [
            "mathematical-functions/ROUND",
            "numbering-functions/ROW_NUMBER",
            "timestamp-functions/FORMAT_TIMESTAMP",
            "timestamp-functions/TIMESTAMP"
        ]
    },
    {
        "instance_id": "bq265",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "Can you provide me with the emails of the top 10 users who have the highest average order value, considering only those users who registered in 2019 and made purchases within the same year?",
        "external_knowledge": null,
        "plan": "1. Get the date level information.\n2. Get all the order level data including the sales value and number of orders.\n3. Combine date level data with the previously captured orders and sales level data.\n4. Calculate the Lifetime value (LTV) of the customer and number of orders placed by them.\n5. Figure out the average order value per user by dividing the LTV by the number of orders placed by that user.\n6. Sort to find the top 10 average order value users.\n",
        "special_function": [
            "date-functions/DATE",
            "date-functions/DATE_DIFF",
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "mathematical-functions/ROUND",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT"
        ]
    },
    {
        "instance_id": "bq266",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "Can you provide me with the names of the products that had the lowest profit margin each month throughout the year 2020, excluding any months where this data isn't available? Please list them in chronological order based on the month.",
        "external_knowledge": null,
        "plan": "1. Calculate profit as the difference between retail price and cost.\n2. Assign a rank to each product within a month based on profit margin and partition the ranking by year and month and order products by profit in ascending order within each month.\n3. Retrieve the names of products that have the rank of 1 and return.\n",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "json-functions/STRING",
            "numbering-functions/DENSE_RANK",
            "numbering-functions/RANK",
            "string-functions/CONCAT",
            "string-functions/LPAD",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "timestamp-functions/STRING"
        ]
    },
    {
        "instance_id": "bq271",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "Could you provide me with the country that had the highest profit from orders in 2021 and its profit, considering the difference between the total retail prices and the costs of products sold during the year?",
        "external_knowledge": null,
        "plan": "Extract the inventory item ID and sale price for each order.\n1. Augment the data with the country associated with each user who made a purchase.\n2. Calculate the total product retail price, and total cost.\n3. Figure out the profit through subtracting the total product retail price from the total cost.\n4. Sort the results by the profit.\n5. Return the country name which has the highest monthly profit.\n",
        "special_function": [
            "date-functions/DATE",
            "date-functions/DATE_TRUNC"
        ]
    },
    {
        "instance_id": "bq273",
        "db": "bigquery-public-data.thelook_ecommerce",
        "question": "Could you provide me with the top 5 months where there was the highest increase in profit compared to the previous month for completed orders made by users who came from Facebook, between January 1, 2022, and June 30, 2023?",
        "external_knowledge": null,
        "plan": "1. Convert delivery dates to the month granularity.\n2. Retrieve order-related details, product cost information, user information.\n3. Apply filters to keep only records where the order status is 'Complete', the user traffic source is \u2018Facebook\u2019 and the order created time in the specific period.\n4. Compute total revenue, total profit, and count unique products, orders, and users for each month.\n5. For both revenue and profit, compute a 3-month moving average.\n6. Calculate the difference between the current month's revenue and profit against their respective moving averages.\n7. Calculate month-over-month changes in revenue and profit by comparing with the previous month's figures.\n8. Select the delivery month with the highest increase in profit compared to the prior month.\n",
        "special_function": [
            "date-functions/DATE_TRUNC",
            "navigation-functions/LAG"
        ]
    },
    {
        "instance_id": "bq020_1",
        "db": "bigquery-public-data.genomics_cannabis",
        "question": "What is the name of the reference sequence with the highest variant density in the given cannabis genome dataset?",
        "external_knowledge": null,
        "plan": "1. **Identify Relevant Tables**:\n   - Utilize two tables: one containing variant data and another containing reference sequence data.\n\n2. **Join Tables**:\n   - Perform an inner join on the tables based on matching reference sequence names to combine variant information with reference sequence details.\n\n3. **Filter Variants**:\n   - Include only those variants where there is at least one genotype value greater than zero within the variant calls. This ensures that only relevant variants are considered.\n\n4. **Calculate Variant Density**:\n   - For each reference sequence, calculate the density of variants by dividing the count of variants by the length of the reference sequence. Also, compute the total count of variants and store the reference sequence length for later use.\n\n5. **Group and Aggregate Data**:\n   - Group the results by reference sequence name and reference sequence length to compute the variant counts and densities for each reference sequence.\n\n6. **Order by Density**:\n   - Sort the grouped results in descending order of variant density to prioritize sequences with the highest density of variants.\n\n7. **Select Top Result**:\n   - Limit the results to a single entry to identify the reference sequence with the highest variant density.\n\n8. **Output**:\n   - Extract and display the name of the reference sequence with the highest variant density.",
        "special_function": [
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq020_2",
        "db": "bigquery-public-data.genomics_cannabis",
        "question": "What is the variant density of the cannabis reference with the longest reference length?",
        "external_knowledge": null,
        "plan": "1. **Data Preparation (CTE Setup)**:\n   - Create a common table expression (CTE) to compute necessary metrics for each reference.\n   \n2. **Join Data**:\n   - Join two datasets: one containing variant data and another containing reference length information based on matching reference names.\n\n3. **Filter Data**:\n   - Apply a filter to ensure only those variants are considered where at least one genotype call is greater than zero.\n\n4. **Aggregation**:\n   - Group the data by reference name and reference length.\n   - Calculate the total count of variants for each reference.\n   - Compute the variant density by dividing the count of variants by the reference length.\n\n5. **Final Selection**:\n   - Select all data from the aggregated CTE.\n\n6. **Sorting and Limiting**:\n   - Order the results by reference length in descending order.\n   - In case of ties in reference length, order by reference name.\n   - Limit the result to one row to get the reference with the longest length and its variant density.",
        "special_function": [
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq025",
        "db": "bigquery-public-data.census_bureau_international",
        "question": "Provide a list of the top 10 countries for the year 2020, ordered by the highest percentage of their population under 20 years old. For each country, include the total population under 20 years old, the total midyear population, and the percentage of the population that is under 20 years old.",
        "external_knowledge": null,
        "plan": "1. **Define the Main Query Objective**:\r\n   - Retrieve and analyze the population data for countries, specifically focusing on the population under the age of 20 and its percentage relative to the total population.\r\n\r\n2. **Subquery 1 (Alias `age`)**:\r\n   - **Data Source**: `bigquery-public-data.census_bureau_international.midyear_population_agespecific`\r\n   - **Filters**:\r\n     - `year = 2020`: Only consider data from the year 2020.\r\n     - `age < 20`: Only include population data for individuals under the age of 20.\r\n   - **Selected Columns**:\r\n     - `country_name`: Name of the country.\r\n     - `population`: Population of the specific age group.\r\n     - `country_code`: Country code for joining purposes.\r\n\r\n3. **Subquery 2 (Alias `pop`)**:\r\n   - **Data Source**: `bigquery-public-data.census_bureau_international.midyear_population`\r\n   - **Filters**:\r\n     - `year = 2020`: Only consider data from the year 2020.\r\n   - **Selected Columns**:\r\n     - `midyear_population`: Total midyear population for the country.\r\n     - `country_code`: Country code for joining purposes.\r\n\r\n4. **Join Operation**:\r\n   - **Type**: INNER JOIN\r\n   - **Condition**: `age.country_code = pop.country_code`\r\n   - **Purpose**: Combine age-specific population data with total population data for each country based on matching country codes.\r\n\r\n5. **Aggregation and Calculations**:\r\n   - **Grouped By**: \r\n     - `age.country_name` (Column index 1 in the SELECT clause)\r\n     - `pop.midyear_population` (Column index 3 in the SELECT clause)\r\n   - **Aggregations**:\r\n     - `SUM(age.population) AS under_25`: Calculate the total population under the age of 20 for each country.\r\n     - `ROUND((SUM(age.population) / pop.midyear_population) * 100,2) AS pct_under_25`: Calculate and round to two decimal places the percentage of the population under 20 relative to the total midyear population for each country.\r\n\r\n6. **Ordering**:\r\n   - **Order By**: `pct_under_25 DESC` (Column index 4 in the SELECT clause)\r\n   - **Purpose**: Sort the results in descending order based on the percentage of the population under 20.\r\n\r\n7. **Limit**:\r\n   - **Limit**: `10`\r\n   - **Purpose**: Restrict the result set to the top 10 countries based on the sorted percentage of the population under 20.",
        "special_function": [
            "mathematical-functions/ROUND"
        ]
    },
    {
        "instance_id": "bq025_1",
        "db": "bigquery-public-data.census_bureau_international",
        "question": "Which country has the highest percentage of population under the age of 25 in 2017?",
        "external_knowledge": null,
        "plan": "1. **Filter Data by Year and Age**: Begin by selecting records from the dataset that match the specific year (2017) and where the age is less than 25. This filters the population data to only include those under 25 years old.\n\n2. **Aggregate Population Under 25**: Sum the population values for the filtered records to get the total population under 25 for each country.\n\n3. **Fetch Total Population**: Select the total midyear population for each country for the same year (2017) from another dataset.\n\n4. **Combine Datasets**: Perform an inner join between the two datasets on the country code to combine the total population under 25 with the total midyear population for each country.\n\n5. **Calculate Percentage**: Compute the percentage of the population under 25 by dividing the summed population under 25 by the total midyear population, then multiply by 100 and round to two decimal places.\n\n6. **Group and Order**: Group the results by country and total population, then order the results by the calculated percentage of the population under 25 in descending order.\n\n7. **Select Top Country**: Limit the result to the top entry, which represents the country with the highest percentage of the population under 25.\n\n8. **Return Country Name**: Finally, select and return the name of the country with the highest percentage of the population under 25 in 2017.",
        "special_function": [
            "mathematical-functions/ROUND"
        ]
    },
    {
        "instance_id": "bq338",
        "db": "bigquery-public-data.census_bureau_acs\nbigquery-public-data.geo_census_tracts",
        "question": "Which Brooklyn census tract (by geo ID) had the largest increase in median income from 2010 to 2017?",
        "external_knowledge": null,
        "plan": "What is the difference in median income in Brooklyn by Census tract from 2010 to 2017?\nFind how the median household changed for each Census tract in Brooklyn between 2010 and 2017. See the visualization below for more details",
        "special_function": null
    },
    {
        "instance_id": "bq088",
        "db": "bigquery-public-data.covid19_symptom_search",
        "question": "Can you provide the average levels of anxiety and depression symptoms in the United States for the years 2019 and 2020, and calculate the percentage increase in these symptoms from 2019 to 2020?",
        "external_knowledge": null,
        "plan": "1. **Data Source Selection**:\r\n   - The query utilizes the `bigquery-public-data.covid19_symptom_search.symptom_search_country_weekly` dataset from BigQuery's public data.\r\n\r\n2. **Subquery for 2020 Data**:\r\n   - A subquery (`table_2020`) is executed to calculate the average levels of anxiety and depression symptoms for the year 2020.\r\n   - The `WHERE` clause filters the records to include only those from the US (`country_region_code = \"US\"`) and within the date range from January 1, 2020, to December 31, 2020.\r\n   - The `AVG` function calculates the average for `symptom_Anxiety` and `symptom_Depression`, casting these values to `FLOAT64` for precision.\r\n\r\n3. **Subquery for 2019 Data**:\r\n   - Another subquery (`table_2019`) is executed to calculate the average levels of anxiety and depression symptoms for the year 2019.\r\n   - Similar to the 2020 subquery, the `WHERE` clause filters the records to include only those from the US and within the date range from January 1, 2019, to December 31, 2019.\r\n   - The `AVG` function calculates the average for `symptom_Anxiety` and `symptom_Depression`, casting these values to `FLOAT64` for precision.\r\n\r\n4. **Main Query**:\r\n   - The main query selects the average values calculated in the subqueries:\r\n     - `table_2019.avg_symptom_Anxiety_2019`\r\n     - `table_2020.avg_symptom_Anxiety_2020`\r\n     - `table_2019.avg_symptom_Depression_2019`\r\n     - `table_2020.avg_symptom_Depression_2020`\r\n   - Additionally, it calculates the percentage increase in anxiety and depression symptoms from 2019 to 2020 using the formula:\r\n     - `((table_2020.avg_symptom_Anxiety_2020 - table_2019.avg_symptom_Anxiety_2019)/table_2019.avg_symptom_Anxiety_2019) * 100` as `percent_increase_anxiety`\r\n     - `((table_2020.avg_symptom_Depression_2020 - table_2019.avg_symptom_Depression_2019)/table_2019.avg_symptom_Depression_2019) * 100` as `percent_increase_depression`\r\n\r\n5. **Output**:\r\n   - The final output includes the average levels of anxiety and depression for both 2019 and 2020, along with the calculated percentage increases for both symptoms between the two years.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/DATE"
        ]
    },
    {
        "instance_id": "bq137",
        "db": "bigquery-public-data.census_bureau_usa\nbigquery-public-data.utility_us",
        "question": "Find details about zip code areas within 10 kilometers of the coordinates (-122.3321, 47.6062), including their geographic polygons, land and water area in meters, latitude and longitude points, state code, state name, city, county, and population from the 2010 census data.",
        "external_knowledge": null,
        "plan": "1. **Common Table Expression (CTE) - `zip_pop` Creation**:\r\n   - Query `bigquery-public-data.census_bureau_usa.population_by_zip_2010` table.\r\n   - Select `zipcode` and `population` columns.\r\n   - Filter rows where `gender` is either 'male' or 'female'.\r\n   - Ensure `minimum_age` and `maximum_age` are `NULL` (considering the entire population without age restrictions).\r\n\r\n2. **Main Query - Data Selection and Joining**:\r\n   - Query `bigquery-public-data.utility_us.zipcode_area` table.\r\n   - Select the following columns:\r\n     - `zipcode_geom` as `zipcode_polygon` (geometry of the zip code area),\r\n     - `zipcode` (zip code),\r\n     - `area_land_meters` (land area in square meters),\r\n     - `area_water_meters` (water area in square meters),\r\n     - `ST_GeogPoint(longitude, latitude)` as `lat_lon` (geographical point of the zip code),\r\n     - `state_code` (state abbreviation),\r\n     - `state_name` (full state name),\r\n     - `city` (city name),\r\n     - `county` (county name),\r\n     - `population` (population data from the CTE).\r\n\r\n3. **Join Operation**:\r\n   - Perform an inner join between `zip_area` and `zip_pop` on the `zipcode` column to combine area and population data.\r\n\r\n4. **Distance Filtering**:\r\n   - Filter results where the geographical point of the zip code (`ST_GeogPoint(longitude, latitude)`) is within 10,000 meters (10 kilometers) of the point (-122.3321, 47.6062) using the `ST_DWITHIN` function.\r\n\r\n5. **Final Output**:\r\n   - The final result includes data about zip code areas, such as their geographical polygons, land and water areas, geographical points, and associated population information, filtered to only include zip codes within 10 kilometers of the specified coordinates in Seattle, WA.",
        "special_function": [
            "geography-functions/ST_DWITHIN",
            "geography-functions/ST_GEOGPOINT"
        ]
    },
    {
        "instance_id": "bq023",
        "db": "bigquery-public-data.census_bureau_acs\nbigquery-public-data.fec\nbigquery-public-data.hud_zipcode_crosswalk\nbigquery-public-data.geo_census_tracts",
        "question": "What are the average political donation amounts and median incomes for each census tract identifier in Kings County (Brooklyn), NY, using data from the 2018 ACS and 2020 FEC contributions?",
        "external_knowledge": null,
        "plan": "1. Extract Median Income Data:\n    - Retrieve the median income for each geographical area from the census data.\n\n2. Filter Political Donations by State:\n    - Select donation amounts and corresponding ZIP codes for a specific state from political contribution records.\n\n3. Map ZIP Codes to Census Tracts:\n    - Create a mapping between ZIP codes and census tracts using a crosswalk table.\n\n4. Calculate Average Donations per Census Tract:\n    - Aggregate the donation amounts by census tract, using the mapping from ZIP codes to census tracts, to compute the average donation per tract.\n\n5. Identify Census Tracts in Target County:\n    - Select the census tracts that belong to the specific county of interest, filtering by county and state codes.\n\n6. Combine Data:\n    - Merge the census tract information with the computed average donations and the median income data, ensuring that all tracts in the target county are included, even if there are no corresponding donations or income records.\n\n7. Format and Order Results:\n    - Select the relevant fields for the final output, specifically the census tract identifier, average donation amount, and median income. Sort the results by the census tract identifier for orderly presentation.",
        "special_function": null
    },
    {
        "instance_id": "bq060",
        "db": "bigquery-public-data.census_bureau_international",
        "question": "Which top 3 countries had the highest net migration in 2017 among those with an area greater than 500 square kilometers? And what are their migration rates?",
        "external_knowledge": null,
        "plan": "1. **Filter and Select Data for 2017**: First, select the relevant columns (country name, net migration, and country code) from the dataset containing information about growth rates for the year 2017.\n\n2. **Filter and Join on Country Area**: Next, filter another dataset to include only countries with an area greater than 500 square kilometers. Join this filtered dataset with the previous one on the country code to combine the net migration data with the area data.\n\n3. **Sort and Retrieve Top Country**: Sort the combined data by net migration in descending order and limit the result to the top 3 entry. Finally, select the country name and net migration fields from this result to identify the country with the highest net migration.",
        "special_function": [
            "conversion-functions/CAST"
        ]
    },
    {
        "instance_id": "bq061",
        "db": "bigquery-public-data.census_bureau_acs\nbigquery-public-data.geo_census_tracts",
        "question": "Which census tract has witnessed the largest increase in median income between 2015 and 2018 in California? Tell me the tract code.",
        "external_knowledge": null,
        "plan": "1. **Extract Data for 2018**: Create a temporary dataset containing the geographical IDs and median incomes for the year 2018.\n\n2. **Extract Data for 2015**: Create another temporary dataset containing the geographical IDs and median incomes for the year 2015.\n\n3. **Calculate Income Difference**: Join the 2018 and 2015 datasets based on geographical IDs and calculate the difference in median income between these two years for each geographical ID.\n\n4. **Identify Maximum Increase**: From the dataset of income differences, filter out records that are not relevant to California and then identify the geographical ID with the highest increase in median income.\n\n5. **Retrieve Tract Code**: Join the geographical ID with the highest income increase back to the dataset containing California tract codes to retrieve the specific tract code associated with that geographical ID.",
        "special_function": null
    },
    {
        "instance_id": "bq198",
        "db": "bigquery-public-data.ncaa_basketball",
        "question": "What are the top 5 most successful college basketball teams over the seasons from 1900 to 2000, based on the number of times they had the maximum wins in a season?",
        "external_knowledge": null,
        "plan": "1. **Identify Maximum Wins per Season:**\n   - Select each season within the specified range (1900 to 2000).\n   - For each season, determine the maximum number of wins achieved by any team.\n\n2. **Identify Teams with Maximum Wins:**\n   - For each season, find the teams that achieved the maximum number of wins identified in the previous step.\n   - Ensure the team names are not null.\n\n3. **Create a Distinct List:**\n   - Create a distinct list of seasons and corresponding teams who had the maximum wins in those seasons.\n\n4. **Count Top Performances:**\n   - Group the distinct list by team names.\n   - Count the number of times each team appears in the list, representing how often they had the maximum wins in a season.\n\n5. **Order and Limit Results:**\n   - Sort the teams by the count of top performances in descending order.\n   - If there is a tie in the count, sort the tied teams alphabetically by their names.\n   - Limit the results to the top 5 teams.\n\nBy following these steps, the query identifies and ranks the top 5 most successful college basketball teams based on the number of seasons they had the maximum wins.",
        "special_function": null
    },
    {
        "instance_id": "bq268",
        "db": "bigquery-public-data.google_analytics_sample",
        "question": "Identify the longest number of days between the first visit and the last recorded event (either the last visit or the first transaction) for a user where the last recorded event was associated with a mobile device.",
        "external_knowledge": null,
        "plan": "1. Find the first and last visit dates for each unique visitor.\n2. Determine the first transaction date for visitors with transaction information.\n3. Combine visit, transaction, and device information.\n4. Calculate the time duration in days between the event date (either transactions or last visit) and the first visit date for visitors on mobile devices.\n5. Sorted by duration and return the longest time duration.\n",
        "special_function": [
            "date-functions/DATE",
            "date-functions/DATE_DIFF",
            "date-functions/PARSE_DATE",
            "time-functions/TIME",
            "conditional-functions/CASE",
            "conditional-functions/IFNULL",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq269",
        "db": "bigquery-public-data.google_analytics_sample",
        "question": "Compute the average pageviews per visitor for non-purchase events and purchase events each month between June 1st and July 31st in 2017.",
        "external_knowledge": null,
        "plan": "1. Calculate the average pageviews per visitor for sessions without transactions and non-earning product revenue through dividing pageviews by the number of visitors.\n2. Compute the average pageviews per visitor for sessions with at least one transaction and product revenue between June 1 and July 31, 2017.\n3, Join the results and order the final output by month.\n",
        "special_function": [
            "date-functions/DATE",
            "date-functions/EXTRACT",
            "date-functions/PARSE_DATE",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "string-functions/CONCAT",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq270",
        "db": "bigquery-public-data.google_analytics_sample",
        "question": "What were the monthly add-to-cart and purchase conversion rates, calculated as a percentage of pageviews, from January to March 2017?",
        "external_knowledge": "https://github.com/xlang-ai/Spider2-C/blob/main/Spider2-SQL/external_documents/ga360_hits.eCommerceAction.action_type.md",
        "plan": "1. Filter and count the number of product views with eCommerce action type '2' between January 1, 2017, and March 31, 2017.\n2. Filter and count the number of add-to-cart actions in the specified date range.\n3. Filter and count the number of successful purchase actions and non-null product revenue in the designated period.\n4. Calculate the add-to-cart rate through dividing the number of add-to-cart actions by the number of product views. \n5. Analogously, compute the purchase rate.\n6. Sort the final output by month and return.\n",
        "special_function": [
            "date-functions/DATE",
            "date-functions/EXTRACT",
            "date-functions/PARSE_DATE",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "mathematical-functions/ROUND",
            "string-functions/CONCAT",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq275",
        "db": "bigquery-public-data.google_analytics_sample",
        "question": "Can you provide a list of visitor IDs for those who made their first transaction on a mobile device on a different day than their first visit?",
        "external_knowledge": null,
        "plan": "Calculate the first and last visit dates for each visitor by grouping on visitor ID and taking the minimum and maximum of visit dates respectively.\n1. Identify distinct combinations of visitor ID, visit date, and device category used during each visit.\n2. For each visitor, identify the earliest date on which a transaction occurred and flag these records as having a transaction.\n3. For each transaction, capture the distinct visitor ID, date of transaction, and device category used during the transaction.\n4. Merge the datasets obtained above.\n5. From the combined data, prepare a table where for each visitor, the event date is determined (use the transaction date if it exists; otherwise, use the last visit date) and the device used is specified (use the transaction device if it exists; otherwise, use the device from the last visit).\n6. Select visitors with at least one transaction whose event happened after the first visit and the device used was mobile.\n",
        "special_function": [
            "date-functions/DATE",
            "date-functions/DATE_DIFF",
            "date-functions/PARSE_DATE",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq016",
        "db": "spider2-public-data.deps_dev_v1",
        "question": "Considering only the highest release versions of PYPI packages, which one and its version has the most dependent packages?",
        "external_knowledge": null,
        "plan": "1. Firstly, we declare a system variable to denote the PYPI system.\n2. Identify the highest released versions for each package.\n   - Use a subquery to:\n     - Partition data by `Name`.\n     - Order the partitions by `VersionInfo.Ordinal` in descending order to rank versions.\n     - Assign row numbers to each version within their respective partitions.\n   - Filter to include only the first row (highest version) for each package where:\n     - The `System` is 'PYPI' (using the variable `Sys`).\n     - The `VersionInfo.IsRelease` is true (indicating it is a release version).\n3. Join the table Dependencies with the table defined in Step 2.\n4. Aggregate and order dependencies by name and version.\n5. Restrict the output to only one record, which is the dependency with the highest count of dependent packages.",
        "special_function": [
            "json-functions/STRING",
            "numbering-functions/ROW_NUMBER",
            "timestamp-functions/STRING"
        ]
    },
    {
        "instance_id": "bq062",
        "db": "spider2-public-data.deps_dev_v1",
        "question": "What is the most frequently used license by packages in each system?",
        "external_knowledge": null,
        "plan": "1. Generate a Common Table Expression (CTE) that aggregates the number of distinct packages using each license within each system.\n- Use `CROSS JOIN UNNEST` to handle the array of licenses, effectively normalizing the data for easier counting.\n- Group the results by `System` and `License`.\n2. Generate another CTE that ranks the licenses within each system based on the number of distinct packages using them.\n- Use the `ROW_NUMBER()` window function partitioned by `System` and ordered by `NPackages` in descending order to assign a rank to each license within each system.\n3. Select and output only top ranked licenses for each system.",
        "special_function": [
            "numbering-functions/ROW_NUMBER",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq063",
        "db": "spider2-public-data.deps_dev_v1",
        "question": "What is the github URL of the latest released package from the NPM system that have the highest number of dependencies? Exlcude those package whose names contain character '@' or the URL label is not 'SOURCE_REPO'.",
        "external_knowledge": null,
        "plan": "1. Initialize a variable `Sys` with the value 'NPM' to filter data related to the NPM system.\n2. Create a Common Table Expression (CTE) to identify the latest released version of each package in the NPM system.\n- Select `Name` and `Version` from the `PackageVersions` table.\n- Use `ROW_NUMBER` to assign a unique sequential integer to rows within a partition of the dataset, partitioned by `Name` and ordered by `VersionInfo.Ordinal` in descending order.\n- Filter to include only rows where `VersionInfo.IsRelease` is true.\n- Retrieve only the rows where `RowNumber` equals 1, ensuring only the latest released version is selected for each package.\n3. Create another CTE to find packages with the highest number of dependencies.\n- Select `Name`, `Version`, and the count of dependencies from the `Dependencies` table after joining it with the table created in Step 2.\n- Order the results by the count of dependencies (`NDependencies`) in descending order.\n4. Select the `URL` from the `PackageVersions` table, unnesting the `Links` array to access individual URLs.\n- Filter to include only rows where:\n   - `System` equals `Sys`.\n   - `Name` does not contain the character '@'.\n   - `Label` is 'SOURCE_REPO'.\n   - `lnk.URL` contains 'github.com'.\n5. Limit the result to the top 1, which gives the GitHub URL of the package with the highest number of dependencies among the latest releases.",
        "special_function": [
            "json-functions/STRING",
            "numbering-functions/ROW_NUMBER",
            "string-functions/LOWER",
            "timestamp-functions/STRING",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq028",
        "db": "spider2-public-data.deps_dev_v1",
        "question": "Considering only the latest release versions of NPM package, which packages are the top 3 most popular based on the Github star number, as well as their versions?",
        "external_knowledge": null,
        "plan": "1. Declare system variable: define a variable `Sys` to filter records for the NPM system.\n2. Identify latest release versions:\n- Create a common table expression (CTE) to determine the latest release version for each package.\n- Use `ROW_NUMBER()` window function partitioned by `Name` and ordered by `VersionInfo.Ordinal` in descending order to rank the versions.\n- Filter to keep only the top-ranked version (`RowNumber = 1`) which represents the latest release.\n3. Join latest versions with projects to extract the project name and type and constrain the project type to GITHUB.\n4. Select package details and rank by the number of github stars count:\n5. Limit the final result to the top 3 packages based on the number of GitHub stars and return the package names and versions.",
        "special_function": [
            "json-functions/STRING",
            "numbering-functions/ROW_NUMBER",
            "timestamp-functions/STRING"
        ]
    },
    {
        "instance_id": "bq022",
        "db": "bigquery-public-data.chicago_taxi_trips",
        "question": "Given the taxi trip data in Chicago, tell me the total number of trips and average fare for each 10-minute interval (using rounded-off minutes) of trip durations no more than 1 hour.",
        "external_knowledge": null,
        "plan": "Step 1: Filter and Calculate Duration\n- First, filter and calculate duration. Only include trips where the duration is less than 1 hour (=3600 seconds).\n- Calculate duration and quantiles. Calculate the duration of each trip in minutes and divide the trips into 6 quantiles based on their duration using `NTILE(6) OVER (ORDER BY trip_seconds / 60)`.\n- Aggregate trips and fare. For each duration, count the number of trips and sum the total fare. Then, group the results by `trip_seconds` and `duration_in_minutes`.\nStep 2: Calculate Min and Max Duration for Each Quantile\n- For each quantile, calculate the minimum and maximum duration in minutes using window functions.\n- Sum the trips and total fare for each quantile.\nStep 3: Final Aggregation and Formatting\n- Format the minimum and maximum duration for each quantile into a string representing the range (e.g., \"01m to 10m\").\n- Sum the total trips and calculate the average fare per trip for each duration range.\n- Group and order the results by the formatted duration range",
        "special_function": [
            "mathematical-functions/ROUND",
            "numbering-functions/NTILE",
            "string-functions/FORMAT"
        ]
    },
    {
        "instance_id": "bq076",
        "db": "bigquery-public-data.chicago_crime",
        "question": "Which month generally has the greatest number of motor vehicle thefts in 2016?",
        "external_knowledge": null,
        "plan": "Which month generally has the greatest number of motor vehicle thefts?\nThe following query summarizes the number of MOTOR VEHICLE THEFT incidents for each year and month, and ranks the month\u2019s total from 1 to 12. Then, the outer SELECT clause limits the final result set to the first overall ranking for each year. According to the data, in 3 of the past 10 years, December had the highest number of car thefts",
        "special_function": [
            "date-functions/DATE",
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "numbering-functions/RANK",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT"
        ]
    },
    {
        "instance_id": "bq077",
        "db": "bigquery-public-data.chicago_crime",
        "question": "For each year from 2010 to 2016, what is the highest number of motor thefts in one month?",
        "external_knowledge": null,
        "plan": "1. Filters the crime dataset for motor vehicle theft incidents between 2010 and 2016.\n2. Extracts the month from the date of each incident and groups the data by year and month.\n3. Counts the number of incidents for each year-month combination and ranks the months within each year based on the number of incidents.\n4. Selects the highest number of incidents for each year by filtering for ranking = 1 and orders the final results by year in ascending order.",
        "special_function": [
            "date-functions/DATE",
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "numbering-functions/RANK",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT"
        ]
    },
    {
        "instance_id": "bq350",
        "db": "open-targets-prod.platform",
        "question": "Please display the drug id, drug type and withdrawal status for approved drugs with a black box warning and known drug type among 'Keytruda', 'Vioxx', 'Premarin', and 'Humira'",
        "external_knowledge": null,
        "plan": "1. **Initialize a List of Drug Names**: Start by declaring a list that contains specific drug names of interest ('Keytruda', 'Vioxx', 'Humira', and 'Premarin').\n\n2. **Select Relevant Columns**: Prepare to select the drug ID, trade name, drug type, and withdrawal status from the dataset.\n\n3. **Unnest Trade Names**: Expand the nested list of trade names associated with each drug entry to allow for individual trade names to be examined.\n\n4. **Filter by Trade Name**: Ensure that only those drugs whose trade name matches one of the names in the initialized list are included.\n\n5. **Filter by Approval Status**: Further restrict the results to only include drugs that have been approved.\n\n6. **Filter by Black Box Warning**: Additionally, include only those drugs that have a black box warning.\n\n7. **Exclude Unknown Drug Types**: Finally, exclude any drugs where the drug type is listed as 'Unknown'.\n\nBy following these steps, the query will return the desired information about the specific drugs of interest that meet all the given criteria.",
        "special_function": [
            "other-functions/SET",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq351_1",
        "db": "open-targets-prod.platform",
        "question": "Which target approved symbol has the overall association score closest to the mean score for psoriasis?",
        "external_knowledge": null,
        "plan": "1. **Calculate the Mean Score:**\n   - Compute the average association score for the specified condition from the association data.\n   \n2. **Retrieve Target Symbols:**\n   - Identify all targets associated with the specified condition by joining the association data with the condition data.\n\n3. **Match Targets to Scores:**\n   - Join the target data with the association data to get the approved symbols of the targets.\n\n4. **Compare with Mean Score:**\n   - For each target associated with the specified condition, calculate the absolute difference between its association score and the previously computed mean score.\n\n5. **Find Closest Match:**\n   - Order the targets by the smallest absolute difference to the mean score.\n\n6. **Select Closest Target:**\n   - Limit the result to the single target whose score is closest to the mean score.",
        "special_function": [
            "mathematical-functions/ABS"
        ]
    },
    {
        "instance_id": "bq109",
        "db": "open-targets-genetics.genetics",
        "question": "Find the average, variance, max-min difference, and the QTL source(right study) of the maximum log2(h4/h3) for data where right gene id is \"ENSG00000169174\", h4 > 0.8, h3 < 0.02, reported trait includes \"lesterol levels\", right biological feature is \"IPSC\", and the variant is '1_55029009_C_T'.",
        "external_knowledge": null,
        "plan": "For a given gene, what studies have evidence of colocalisation with molecular QTLs?\n\nWith our variant_disease_coloc and studies, you can find associated GWAS studies with evidence of colocalisation and an H4 greater than 0.8",
        "special_function": [
            "statistical-aggregate-functions/VAR_SAMP",
            "statistical-aggregate-functions/VARIANCE",
            "string-functions/CONCAT"
        ]
    },
    {
        "instance_id": "bq276",
        "db": "bigquery-public-data.persistent_udfs\nbigquery-public-data.noaa_hurricanes\nbigquery-public-data.geo_international_ports\nbigquery-public-data.geo_us_boundaries",
        "question": "Can you provide me with the details of the port that has been affected by the highest average wind speed of tropical storms in region number 6585 including the port name, storm name and the average storm category? Only consider named storms in the North Atlantic basin with wind speeds of at least 35 knots and at least a minimal tropical storm strength on the SSHS scale. Also, ensure that this port is located within a U.S. state boundary.",
        "external_knowledge": null,
        "plan": "1. Filter records from a hurricane dataset based on specific criteria (e.g., basin, wind speed, storm name, and storm category).\n2. For each selected record, convert certain radius measurements from kilometers to nautical miles.\n3. Compute geographical points in four compass directions from the storm's center using the converted nautical mile radii.\n4. Construct a polygon representing the boundary of a tropical storm based on these points.\n5. Ensure the port is within both the state's geographical boundary and the tropical storm's polygon.\n6. Filters the ports based on specific attributes (e.g., region number = 6585).\n7. Aggregate data by grouping on unique identifiers and geographical attributes of the ports, summarizing attributes like storm seasons, storm count, storm names, and average storm characteristics.\n8. Sort the results by average wind speed in descending order.\n9. Output detailed information about the port that has experienced the most severe average wind speeds during storms, including the port's geographical data, details of the storms affecting it, and the storm polygon data.\n",
        "special_function": [
            "aggregate-functions/STRING_AGG",
            "geography-functions/ST_ASTEXT",
            "geography-functions/ST_MAKELINE",
            "geography-functions/ST_MAKEPOLYGON",
            "geography-functions/ST_WITHIN",
            "other-functions/DECLARE"
        ]
    },
    {
        "instance_id": "bq278",
        "db": "bigquery-public-data.sunroof_solar",
        "question": "Please provide me with details about the state that has the highest number of buildings suitable for solar installations according to Google Maps data, including the state name, percent of buildings in Google Maps covered by Project Sunroof, total solar energy generation potential and potential carbon dioxide abatement.",
        "external_knowledge": null,
        "plan": "1. Compute the average percentage of buildings from the mapping database that are covered by a specific solar project.\n2. Compute the total potential yearly energy generation from solar installations, measured in kilowatt-hours.\n3. Estimate the potential reduction in carbon dioxide emissions due to solar installations.\n4. Calculate the total number of buildings suitable for solar installations as recorded in a mapping database by summing up the counts of qualified buildings across each state.\n5. Sort the query results by the number of buildings in Google Map suitable for solar in descending order.\n6. Return the related information for the state which has the largest number of qualified buildings.\n",
        "special_function": [
            "conversion-functions/CAST",
            "mathematical-functions/ROUND"
        ]
    },
    {
        "instance_id": "bq352",
        "db": "bigquery-public-data.sdoh_cdc_wonder_natality\nbigquery-public-data.census_bureau_acs",
        "question": "Please list the average number of prenatal weeks in 2018 for counties in Wisconsin where more than 5% of the employed population had commutes of 45-59 minutes in 2017.",
        "external_knowledge": null,
        "plan": "Is there an association between high commute times [from ACS] and average number of prenatal visits in Wisconsin by County?\nThis query examines the potential correlation between the average number of prenatal visits and length of commutes",
        "special_function": [
            "mathematical-functions/ROUND",
            "string-functions/SUBSTR"
        ]
    },
    {
        "instance_id": "bq041",
        "db": "bigquery-public-data.stackoverflow",
        "question": "What are the monthly statistics for new StackOverflow users created in 2021, including the percentage of new users who asked questions and the percentage of those who asked questions and then answered questions within their first 30 days?",
        "external_knowledge": null,
        "plan": "1. **Initialize Variables**: Define the year of interest and the period (in days) for tracking user activity after sign-up.\n\n2. **Filter Users by Year**: Retrieve all users who registered in the specified year.\n\n3. **Join and Aggregate User Questions**:\n   - Join the filtered users with their questions posted within the specified period after sign-up.\n   - Count the number of questions each user asked within this period.\n   - Identify the date of their first question within this period.\n\n4. **Join and Aggregate User Answers**:\n   - Further join the result with answers posted by these users.\n   - Count the number of answers each user provided after their first question within the specified period.\n\n5. **Calculate Monthly Statistics**:\n   - Extract the month from each user\u2019s sign-up date.\n   - Count the total number of new users each month.\n   - Count the number of users who asked at least one question within the specified period.\n   - Calculate the percentage of users who asked questions.\n   - Count the number of users who asked questions and then answered within the specified period.\n   - Calculate the percentage of users who asked questions and then answered.\n\n6. **Aggregate and Order Results**:\n   - Group the statistics by month.\n   - Order the results chronologically by month.",
        "special_function": [
            "date-functions/DATE_DIFF",
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "mathematical-functions/ROUND",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "conditional-functions/CASE",
            "other-functions/SET"
        ]
    },
    {
        "instance_id": "bq123",
        "db": "bigquery-public-data.stackoverflow",
        "question": "Which day of the week has the third highest percentage of questions answered within an hour?",
        "temporal": "Yes",
        "external_knowledge": null,
        "plan": "Which day of the week has most questions answered within an hour?\nIn this query, we find the best day of the week to ask questions to get an answer very quickly. The query returns day of the week as integers from 1 to 7 (1 = Sunday, 2 = Monday, etc), and the number of questions and answers on each day. We also query how many of these questions received an answer within 1 hour of submission, and the corresponding percentage. The volume of questions and answers is the highest in the middle of the week (Tue, Wed, and Thur), but questions are answered within 1 hour is higher on Saturdays and Sundays",
        "special_function": [
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "mathematical-functions/ROUND",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "timestamp-functions/TIMESTAMP_ADD"
        ]
    },
    {
        "instance_id": "bq280",
        "db": "bigquery-public-data.stackoverflow",
        "question": "Please provide the display name of the user who has answered the most questions on Stack Overflow, considering only users with a reputation greater than 10.",
        "external_knowledge": null,
        "plan": "1. Calculate the total number of answers each user has posted and filter out entries where the user ID is not available. \n2. Group the results by user ID to ensure each user is represented once with their total answer count.\n3. Select users who have both a visible display name and a reputation greater than 10.\n4. Combine the user-specific data (display names and reputation) with their corresponding answer counts into a single dataset.\n5. Implement a ranking system within the combined dataset based on the number of answers each user has posted. \n6. Order the users in descending order of answer count.\n7. Extract and return the display name of the top-ranked user.\n",
        "special_function": [
            "numbering-functions/RANK",
            "numbering-functions/ROW_NUMBER"
        ]
    },
    {
        "instance_id": "bq126",
        "db": "bigquery-public-data.the_met",
        "question": "What are the titles, artist names, mediums, and original image URLs of objects with 'Photograph' in their names from the 'Photographs' department, created by known artists, with an object end date of 1839 or earlier?",
        "external_knowledge": null,
        "plan": "What are the earliest photographs in the collection?\nThe Met\u2019s Department of Photographs has some of the earliest photographic works. This query retrieves artwork from the \u201cPhotograph\u201d department and joins the object and image tables to return the results, presented with the oldest items first. In this case, we see the British photography pioneer William Henry Fox Talbot\u2019s botanical images.",
        "special_function": null
    },
    {
        "instance_id": "bq286",
        "db": "bigquery-public-data.usa_names",
        "question": "Can you tell me the name of the most popular female baby in Wyoming for the year 2021, based on the proportion of female babies given that name compared to the total number of female babies given the same name across all states?",
        "external_knowledge": null,
        "plan": "1. Calculate the total count of each name grouped by name, gender, and year.\n2. Join the above result with the main dataset containing records of names based on matching names, genders, and years.\n3. Filter the joined data to focus on records where the gender is female ('F') and the state is specific ('WY'), and the year is a particular year (2021).\n4. For the filtered results, calculate the ratio of the count of each name to its total count across all states.\n5. Sort the results in descending order based on the calculated ratio.\n6. Return the name with the highest proportion.\n",
        "special_function": null
    },
    {
        "instance_id": "bq042",
        "db": "bigquery-public-data.noaa_gsod",
        "question": "Help me analyze the weather conditions (including temperature, wind speed and precipitation) at NYC's airport LaGuardia for June 12, year over year, starting from 2011 to 2020.",
        "external_knowledge": null,
        "plan": "1. Filter Data for Specific Dates and Location: Extract the records for the specified date (June 12) across the given range of years (2011-2020) and for the specific location (LaGuardia airport).\n\n2. Handle Missing or Invalid Data: Replace any placeholder values indicating missing data with `NULL` for temperature and wind speed, and with `0` for precipitation.\n\n3. Calculate Averages: Compute the average values for temperature, wind speed, and precipitation on June 12 for each year.\n\n4. Organize Results: Create a timestamp for each record, group the results by this timestamp, and sort the output in ascending order of the timestamp for clear year-over-year analysis.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/DATE",
            "string-functions/CONCAT",
            "string-functions/REPLACE",
            "timestamp-functions/TIMESTAMP",
            "conditional-functions/IF"
        ]
    },
    {
        "instance_id": "bq047",
        "db": "bigquery-public-data.noaa_gsod\nbigquery-public-data.new_york",
        "question": "Could you help me analyze the relationship between each complaint type and daily temperature in New York city, focusing on data in airports LaGuardia and JFK over the 10 years starting from 2008? Calculate the total complaint count, the total day count, and the Pearson correlation coefficient (rounded to 4 decimals) between temperature and both the count and percentage of each common (>5000 occurrences) and strongly correlated (absolute value > 0.5) complaint type.",
        "external_knowledge": null,
        "plan": "1. Temperature Data Preparation:\n    - Extract and clean weather data for the specified 10-year period, focusing on the relevant locations.\n    - Transform date components into a single timestamp and handle any placeholder values for temperature.\n    - Calculate the average temperature for each day from the cleaned weather data.\n\n2. Prepare Complaint Data:\n    - Extract and aggregate complaint data by type and date, counting the number of complaints per day for each type.\n    - Calculate the daily proportion of each complaint type relative to the total complaints on that day.\n\n3. Join Weather and Complaint Data:\n    - Combine the weather data with the complaint data based on matching dates.\n    - Aggregate this joined data by complaint type and temperature to compute the average daily counts and proportions of each complaint.\n\n4. Analyze and Filter Results:\n    - Compute the correlation between temperature and both the average daily count and proportion of each complaint type using function `CORR`.\n    - Filter the results to include only those complaint types that are both common (more than 5000 total occurrences) and strongly correlated (with absolute correlation value greater than 0.5).\n    - Sort the results by the strength of the correlation.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/DATE",
            "mathematical-functions/ABS",
            "mathematical-functions/ROUND",
            "statistical-aggregate-functions/CORR",
            "string-functions/CONCAT",
            "string-functions/REPLACE",
            "timestamp-functions/TIMESTAMP",
            "conditional-functions/IF"
        ]
    },
    {
        "instance_id": "bq048",
        "db": "bigquery-public-data.noaa_gsod\nbigquery-public-data.new_york",
        "question": "Which common complaint types have the strongest positive and negative correlation with wind speed respectively, given the data in NYC JFK Airport from year 2011 to 2020? Also, provide the corresponding correlation values (rounded to 4 decimals).",
        "external_knowledge": null,
        "plan": "1. Aggregate Wind Speed Data: Create a dataset with daily average wind speed values for a specific location and time range, replacing erroneous values with nulls.\n\n2. Compute Daily Complaint Data: Generate daily complaint counts and their proportions relative to all complaints for different complaint types over the same time range.\n\n3. Join Weather and Complaint Data: Merge the weather dataset with the complaint dataset on their date fields to align daily wind speed data with daily complaint data.\n\n4. Calculate Correlations: For each complaint type, calculate the correlation between the average daily wind speed and the average daily complaint count, filtering out complaint types with insufficient data.\n\n5. Identify Extremes: Select the complaint types with the strongest positive and negative correlations with wind speed, and report these types along with their correlation values.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/DATE",
            "mathematical-functions/ROUND",
            "statistical-aggregate-functions/CORR",
            "string-functions/CONCAT",
            "string-functions/REPLACE",
            "timestamp-functions/TIMESTAMP",
            "conditional-functions/IF"
        ]
    },
    {
        "instance_id": "bq279",
        "db": "bigquery-public-data.austin_bikeshare",
        "question": "Can you provide the number of distinct active and closed bike share stations for each year 2013 and 2014 in a chronological view?",
        "external_knowledge": null,
        "plan": "1. Extract the year and start station ID from the trips data for the years 2013 and 2014.\n2. Join the extracted trip data with the station data on the station ID to consolidate trip and station information.\n3. Limit the joined data to only include records from the years 2013 and 2014.\n4. For each year, count the distinct station IDs where the station status is 'active'. This involves filtering the joined data for 'active' stations and then counting distinct station IDs for each year.\n5. Similarly, for each year, count the distinct station IDs where the station status is 'closed'. This involves filtering the joined data for 'closed' stations and then counting distinct station IDs.\n6. Group the results by year to ensure that the counts of active and closed stations are organized by year.\n7. Order the final results by year to provide a chronological view of the data.\n",
        "special_function": [
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT",
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE"
        ]
    },
    {
        "instance_id": "bq281",
        "db": "bigquery-public-data.austin_bikeshare",
        "question": "What is the highest number of electric bike rides lasting more than 10 minutes taken by subscribers with 'Student Membership' in a single day, excluding rides starting or ending at 'Mobile Station' or 'Repair Shop'?",
        "external_knowledge": null,
        "plan": "1. Filter the dataset to exclude records where the starting or ending locations are listed as either 'Mobile Station' or 'Repair Shop'.\n2. Narrow down the dataset to include only those records where users have students subscription type and the equipment used is electric.\n3. Consider only records where the duration of usage is greater than ten minutes.\n4. Organize the filtered data by grouping it based on the year, month, and day of the start time.\n5. For each grouped set of data (each day), count the total number of records that match the earlier set conditions.\n6. Order the results by the count of records in descending order to identify the date with the highest number of trips meeting all the specified conditions.\n7. Limit the output to only the top result from the sorted list and show the maximum usage in a single day under the defined conditions.\n",
        "special_function": [
            "date-functions/EXTRACT",
            "datetime-functions/EXTRACT",
            "interval-functions/EXTRACT",
            "time-functions/EXTRACT",
            "timestamp-functions/EXTRACT"
        ]
    },
    {
        "instance_id": "bq282",
        "db": "bigquery-public-data.austin_bikeshare",
        "question": "Can you tell me the numeric value of the active council district in Austin which has the highest number of bike trips that start and end within the same district, but not at the same station?",
        "external_knowledge": null,
        "plan": "1. Filter the stations table to keep records whose status is 'active'.\n2. Perform an inner join between the trips table and the filtered active stations.\n3. Select the district from the stations table for end stations that are active and match the end station ID from the trips table.\n4. Include only those trips where the starting district is present in the list of active end station districts.\n5. Exclude trips where the start station ID is the same as the end station ID.\n6. Group the results by the district and count the number of trips originating from each district.\n7. Order the districts by the descending count of trips to find the district with the highest number of trips.\n8. Limit the output to the district with the maximum number of trips.",
        "special_function": [
            "conversion-functions/SAFE_CAST"
        ]
    },
    {
        "instance_id": "bq283",
        "db": "bigquery-public-data.austin_bikeshare",
        "question": "What is the combined percentage of all bike trips that start from the top 15 most used active stations in Austin?",
        "external_knowledge": null,
        "plan": "1. Calculate the total number of trips originating from each station.\n2. Assign a rank to each station based on the descending order of total trips, where the station with the highest number of trips has the highest rank.\n3. Calculate the percentage of total trips that each station represents by dividing the number of trips from that station by the total number of trips from all stations.\n4. Select only those stations that rank within the top 15.\n5. Join the data of the top 15 stations with another dataset that contains additional details about each station.\n6. From the joined data, filter out stations to keep only those that are currently active.\n7. From the filtered active top 15 stations, select the station with the highest rank.\n8. Retrieve the percentage of total trips for this station and display the result.\n",
        "special_function": [
            "mathematical-functions/ROUND",
            "numbering-functions/RANK"
        ]
    },
    {
        "instance_id": "bq329",
        "db": "bigquery-public-data.austin_bikeshare",
        "question": "Which bike station in the Austin bikeshare system has the lowest average trip duration? I want the station ID.",
        "external_knowledge": null,
        "plan": "1. **Define Data Sources**:\n   - Establish temporary datasets for bike stations and trip data by selecting all relevant columns from each respective source.\n\n2. **Prepare Trip Data**:\n   - Within the trip data, ensure proper data types by safely converting necessary fields to integers and extracting the required columns for analysis.\n\n3. **Calculate Average Trip Duration**:\n   - Group the trip data by the starting station and calculate the average trip duration for each group.\n\n4. **Join Data**:\n   - Merge the average trip duration data with the station data based on the station identifier.\n\n5. **Determine Station with Lowest Average Duration**:\n   - Sort the merged dataset by the average trip duration in ascending order.\n   - Select the station identifier of the station with the lowest average trip duration.\n   - Limit the result to only one record to get the station with the absolute lowest average trip duration.",
        "special_function": [
            "conversion-functions/SAFE_CAST"
        ]
    },
    {
        "instance_id": "bq284",
        "db": "bigquery-public-data.bbc_news",
        "question": "Can you provide a breakdown of the total number of articles into different categories and the percentage of those articles that mention \"Education\" within each category (tech, sport, business, politics, and entertainment) from the BBC News dataset?",
        "external_knowledge": null,
        "plan": "1. Group all records by their category.\n2. For each category group, count the total number of records.\n3. For each category, count the number of records where the body of the text contains the word 'Education'.\n4. For each category, count the total number of records that belong to the current category.\n5. For each category, calculate the percentage of records that mention 'Education' by dividing the count of 'Education' Mentions by the count of total records and then multiply by 100 to get a percentage.\n6. Combine the total count and the calculated percentage for each category into a single output table.\n",
        "special_function": [
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE"
        ]
    },
    {
        "instance_id": "bq285",
        "db": "bigquery-public-data.fdic_banks",
        "question": "Could you provide me with the zip code of the location that has the highest number of bank institutions in Florida?",
        "external_knowledge": null,
        "plan": "1. Retrieve the FIPS code for Florida from a dataset that contains FIPS codes for all states.\n2. Limit the data to zip codes that are only in the Florida state by using FIPS codes to filter the dataset.\n3. From a dataset containing institution locations, perform an aggregation to count the number of locations in each zip code.\n4. Combine the filtered list of zip codes with the aggregated location counts.\n5. Group the data from the join by zip code and sum the counts of locations. \n6. Order the results in descending order based on the sum of location counts.\n7. Limit the result to the top entry, which represents the zip code with the highest number of locations.\n",
        "special_function": null
    },
    {
        "instance_id": "bq287",
        "db": "bigquery-public-data.fdic_banks\nbigquery-public-data.census_bureau_acs",
        "question": "What is the employment rate (only consider population over 16) in the Utah zip code that has the fewest number of bank locations based on American Community Survey data in 2017?",
        "external_knowledge": null,
        "plan": "1. Retrieve the FIPS code for the state of Utah.\n2. Use the Utah FIPS code to filter and obtain a list of ZIP codes associated with Utah from a dataset containing ZIP codes and their corresponding state FIPS codes.\n3. For each ZIP code in Utah, count the number of banking institution locations and ensure that only ZIP codes with valid state and state name information are considered.\n4. Join the banking locations dataset with the banking institutions dataset.\n5. For each ZIP code in Utah, calculate the employment rate using the population over 16 and the employed population.\n6. Combine the datasets containing the Utah ZIP codes, the number of bank locations per ZIP code, and the employment rates.\n7. From the combined dataset, select the employment rate for the ZIP code that has the fewest number of banking institution locations.\n8. Order the results by the number of locations in ascending order.\n9. Limit the result to just one record to find the ZIP code with the lowest number of bank locations and its corresponding employment rate.\n",
        "special_function": [
            "conversion-functions/CAST",
            "json-functions/STRING",
            "mathematical-functions/ROUND",
            "mathematical-functions/SAFE_DIVIDE",
            "timestamp-functions/STRING"
        ]
    },
    {
        "instance_id": "bq288",
        "db": "bigquery-public-data.fdic_banks",
        "question": "Could you tell me the number of banking institutions in the state with the highest total assets for banks established between 1900 and 2000 (both included) and its name starting with \"Bank\"?",
        "external_knowledge": null,
        "plan": "1. Calculate the number of institutions per state.\n2. Gather detailed information about the total assets for each state.\n3. Join the results above based on the matching state names.\n4. Sort the results by the total assets in descending order to bring the state with the highest sum of assets to the top.\n5. Limit the output to only the top record, which corresponds to the state with the highest total assets among the filtered institutions.\n6. Display the count of institutions for the state with the highest total assets.\n",
        "special_function": null
    },
    {
        "instance_id": "bq289",
        "db": "bigquery-public-data.geo_us_census_places",
        "question": "Can you find the shortest distance between any two amenities (either a library, place of worship, or community center) located within Philadelphia?",
        "external_knowledge": null,
        "plan": "1. Extract all records where the place name matches 'Philadelphia'.\n2. For each point feature from a global geographic dataset, check if the point lies within the Philadelphia area.\n3. From the point's tags, filter those records where the tag key indicates an 'amenity' and the value is one of the specified types (library, place of worship, community center).\n4. Extract the value of the 'amenity' tag for each qualifying point.\n5. Perform a self-join on the amenities dataset to compare each amenity with every other amenity.\n6. For each pair of amenities (ensuring pairs are unique and non-repeating by comparing IDs), calculate the geographical distance between them.\n7. Assign a row number to each paired record, partitioned by the ID of the first amenity and ordered by the calculated distance.\n8. From the results of the self-join, filter to retain those records where the row number is 1.\n9. Order these records by distance in ascending order to find the pair with the shortest distance among all.\n",
        "special_function": [
            "geography-functions/ST_CONTAINS",
            "geography-functions/ST_DISTANCE",
            "numbering-functions/ROW_NUMBER",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq226",
        "db": "bigquery-public-data.goog_blockchain_cronos_mainnet_us",
        "question": "Can you find me the complete url of the most frequently used sender's address on the Cronos blockchain since January 1, 2023, where transactions were made to non-null addresses and in blocks larger than 4096 bytes?",
        "external_knowledge": null,
        "plan": "1. Start by joining two datasets based on a common identifier which associates transaction records with corresponding block records.\n2. Include only records where the transaction destination address is specified.\n3. Consider only blocks that are larger than 4096 bytes.\n4. Restrict the data to records timestamped after \u20182023-01-01 00:00:00\u2019 for both transactions and blocks.\n5. For each transaction record, construct a URL using a predefined format concatenated with the source address from the transaction.\n6. Group the data by the source address of the transactions.\n7. Count the number of transactions for each unique source address and sort these counts in descending order to find the most frequent source address.\n8. Return the link to the source address with the highest count of transactions.\n",
        "special_function": [
            "string-functions/CONCAT",
            "timestamp-functions/TIMESTAMP"
        ]
    },
    {
        "instance_id": "bq320",
        "db": "bigquery-public-data.idc_v11",
        "question": "What is the total count of StudyInstanceUIDs that have a segmented property type of '80891009' and belong to the 'Community' or 'nsclc_radiomics' collections?",
        "external_knowledge": null,
        "plan": "1. **Identify the Main Query Objective:**\n   - The main goal is to count unique instances based on specific criteria involving properties and collections.\n\n2. **Specify the Conditions for Segmented Property Type:**\n   - Check for instances where a particular property type matches the given code, ignoring case sensitivity.\n\n3. **Specify the Conditions for Collection Membership:**\n   - Check for instances that belong to either of the specified collections.\n\n4. **Combine the Conditions Using Nested Queries:**\n   - Use nested queries to ensure that only instances meeting both conditions are considered.\n     - First, create a subquery to filter instances by the segmented property type.\n     - Second, create another subquery to filter instances by the collection membership.\n     - Use an intersection operation to find instances that satisfy both subquery conditions.\n\n5. **Aggregate and Count the Results:**\n   - Count the total number of unique instances from the combined results of the nested subqueries.\n\n6. **Return the Total Count:**\n   - The final output is the count of instances meeting all specified conditions.",
        "special_function": [
            "string-functions/LOWER"
        ]
    },
    {
        "instance_id": "bq321",
        "db": "bigquery-public-data.idc_v14",
        "question": "How many unique StudyInstanceUIDs are there from the DWI, T2 Weighted Axial, Apparent Diffusion Coefficient series, and T2 Weighted Axial Segmentations in the 'qin_prostate_repeatability' collection?",
        "external_knowledge": null,
        "plan": "1. **Identify Relevant Records**:\n   - Create a temporary dataset that includes unique identifiers from records that match specific criteria within a given collection.\n   - Filter these records based on a list of specified descriptions.\n\n2. **Additional Filtering with Nested Data**:\n   - Create another temporary dataset that includes unique identifiers from records that match a different specific description within the same collection.\n   - Additionally, this step involves expanding nested data fields to match the criteria.\n\n3. **Combine Results**:\n   - Combine the unique identifiers from both temporary datasets into a single dataset.\n   - Use a union operation to ensure all relevant records are included.\n\n4. **Count Unique Identifiers**:\n   - Count the number of unique identifiers in the combined dataset to determine the total number of unique instances that meet the criteria.",
        "special_function": [
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "bq322",
        "db": "bigquery-public-data.idc_v15",
        "question": "What is the most common modality in the 'Community' and 'nsclc_radiomics' collections?",
        "external_knowledge": null,
        "plan": "1. **Define a Common Subquery**: Create a subquery to count the occurrences of each type of modality within the specified collections.\n\n2. **Identify Relevant Studies**: Within the subquery, filter the dataset to include only the studies that belong to the specified collections.\n\n3. **Group and Count Modalities**: Group the filtered data by modality type and count the number of occurrences for each modality.\n\n4. **Sort and Select the Most Common Modality**: In the main query, order the results by the frequency of occurrences in descending order and select the top result to find the most common modality.\n\nBy following these steps, the query efficiently identifies the most common modality within the specified collections.",
        "special_function": null
    },
    {
        "instance_id": "bq227_1",
        "db": "bigquery-public-data.london_crime\nbigquery-public-data.london_fire_brigade\nbigquery-public-data.london_fire_brigade",
        "question": "Could you provide the annual percentage share of the total crime committed by the top 5 minor crime categories in London year by year?",
        "external_knowledge": null,
        "plan": "1. Aggregate the total values for each category, year, and month combination.\n2. Identify the top categories based on aggregated values. \n3. Rank categories by their total and classify the top five categories.\n4. Summarize the values for the categorized data (top five versus others) for each year, without distinguishing by month or specific category anymore.\n5. Aggregate these sums over each year to compute the total annual value for both the top categories and others.\n6. For each year, calculate the percentage share of the total value that the top categories represent by dividing the total value of top categories by the total annual value and multiplying by 100 to convert this fraction into a percentage.\n7. From the results, filter out the data to only show the percentage values for the top categories across each year.\n8. Finally, order the resulting data by year.\n",
        "special_function": [
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE"
        ]
    },
    {
        "instance_id": "bq227_2",
        "db": "bigquery-public-data.london_crime\nbigquery-public-data.london_fire_brigade\nbigquery-public-data.london_fire_brigade",
        "question": "Could you provide the total number of 'Other Theft' incidents within the 'Theft and Handling' category for each year in the Westminster borough?",
        "external_knowledge": null,
        "plan": "1. Group data by year, month, borough, and crime categories.\n2. Sum the values in each group to get a total count of incidents per group.\n3. Categorize the crime data into two divisions for the major crime category. If the major category is specified as 'Theft and Handling', label it as such; otherwise, label it as 'Other'.\n4. Similarly, categorize the minor crime category. If the minor category matches 'Other Theft', keep the category name; otherwise, label it as 'Other'.\n5. Filter the results to focus only on the borough 'Westminster' and exclude the 'Other' categories for both major and minor divisions.\n6. Calculate the total incidents per year by summing up the totals from the filtered results. \n7. Group these results by year, major division, and minor division.\n8. Finally, order the summarized data by year.",
        "special_function": [
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE"
        ]
    },
    {
        "instance_id": "bq228",
        "db": "bigquery-public-data.london_crime\nbigquery-public-data.london_fire_brigade\nbigquery-public-data.london_fire_brigade",
        "question": "Please provide a list of the top three major crime categories in the borough of Barking and Dagenham, along with the number of incidents in each category.",
        "external_knowledge": null,
        "plan": "1. Calculate and rank the sum of crime incidents by major category within each borough.\n2. Group the data by both borough and major category to aggregate the total number of crime incidents for each category within each borough.\n3. Apply a ranking function to order the crime categories within each borough based on the aggregated sum of incidents, in descending order. \n4. Retrieve the borough, major category, ranking, and total number of incidents.\n5. Include only those records where the rank is within the top 3 for each borough.\n6. Further filter to include only records pertaining to Barking and Dagenham.\n7. Sort the final output first by borough and then by the ranking within that borough to show the top crime categories orderly.\n8. Display the major crime categories with the most incidents in the specified borough.\n",
        "special_function": [
            "numbering-functions/RANK"
        ]
    },
    {
        "instance_id": "bq325",
        "db": "bigquery-public-data.open_targets_genetics",
        "question": "What are the top 10 genes with the lowest p-values across studies?",
        "external_knowledge": null,
        "plan": "1. **Create a Common Table Expression (CTE)**: Define a temporary result set to hold intermediate results for easier querying and readability.\n\n2. **Select Required Columns**: Within the CTE, select the necessary columns including study identifiers, gene names, and p-values.\n\n3. **Join Tables**: Perform the necessary joins between the tables to combine information about gene associations, study metadata, gene details, and variant details. Ensure the joins are based on appropriate matching columns.\n\n4. **Rank Genes**: Use the window function to assign a unique row number to each gene within each study, ordered by p-value in ascending order. This ranking helps identify the gene with the lowest p-value within each study.\n\n5. **Filter Top Genes per Study**: In the main query, filter the results to include only the top-ranked gene (i.e., the gene with the lowest p-value) for each study.\n\n6. **Order and Limit Results**: Sort the filtered genes by their p-values in ascending order to identify the genes with the lowest p-values across all studies.\n\n7. **Return Top Results**: Limit the final output to the top 10 genes with the lowest p-values, fulfilling the requirement to find the top 10 genes with the lowest p-values across studies.",
        "special_function": [
            "numbering-functions/ROW_NUMBER"
        ]
    },
    {
        "instance_id": "bq230",
        "db": "bigquery-public-data.usda_nass_agriculture",
        "question": "Can you provide the maximum amount of corn produced (measured in bushels) by each state in the year 2018, listing the results by state name?",
        "external_knowledge": null,
        "plan": "1. Select and group data by state name, commodity description, and year.\n2. Filter the data to include only records for crop group 'FIELD CROPS', data type like 'PRODUCTION', at the state level, where the measured value is not null and the units are specified as bushels.\n3. Calculate the total amount of the commodity produced per state, per commodity, per year.\n4. Filter the entries for 2018 and 'CORN'.\n5. For each state, find the maximum total produce amount recorded for that commodity.\n6. Display the state name and the maximum total produce amount for the specified commodity and year.\n7. Order the results by state name to present the data in a sorted manner by geographical location.\n",
        "special_function": [
            "timestamp-functions/TIMESTAMP_TRUNC"
        ]
    },
    {
        "instance_id": "bq231",
        "db": "bigquery-public-data.usda_nass_agriculture",
        "question": "Which state produced the most mushrooms in the year 2022 according to the horticulture production statistics?",
        "external_knowledge": null,
        "plan": "1. Apply a filter to only include records that belong to group horticulture, type production, at the state level aggregation, and for commodity mushrooms. Additionally, records with null values in the value field are excluded.\n2. Sum up the values grouped by state, commodity, and year to get the total production for mushrooms per state per year.\n3. Filter to include only the data from 2022.\n4. For each state, find the maximum total production value of mushrooms.\n5. Select the state name with the highest production value of mushrooms and return.\n",
        "special_function": [
            "timestamp-functions/TIMESTAMP_TRUNC"
        ]
    },
    {
        "instance_id": "bq326",
        "db": "bigquery-public-data.world_bank_health_population",
        "question": "How many countries experienced both a change in population and a change in Current health expenditure per capita, PPP (current international $) of greater than 1 in the year 2018?",
        "external_knowledge": null,
        "plan": "1. **Unpivot Yearly Data**:\n   - Transpose the yearly data columns into rows to create a more manageable format for further analysis.\n\n2. **Filter and Format Data**:\n   - Select relevant columns and filter the data for years starting from 2010. Convert the year and population values into appropriate data types.\n\n3. **Calculate Previous Population**:\n   - Use a window function to calculate the previous year's population for each country to enable the calculation of population changes.\n\n4. **Calculate Population Change for 2018**:\n   - Calculate the change in population for the year 2018 by comparing it to the previous year's population. Handle potential division by zero errors gracefully.\n\n5. **Filter Health Expenditure Data**:\n   - Select and filter the health expenditure per capita data for the specific indicator of interest. Use a window function to calculate the previous year's expenditure.\n\n6. **Calculate Health Expenditure Change for 2018**:\n   - Calculate the change in health expenditure per capita for the year 2018 by comparing it to the previous year's expenditure. Handle potential division by zero errors gracefully.\n\n7. **Join and Filter Results**:\n   - Join the population change data and the health expenditure change data on the country identifier. Filter the joined data to find countries that experienced both a significant population change and a significant health expenditure change in 2018.\n\n8. **Count the Countries**:\n   - Count the number of countries that meet the criteria of having both changes greater than 1 in the specified year.",
        "special_function": [
            "conversion-functions/CAST",
            "debugging-functions/ERROR",
            "mathematical-functions/ROUND",
            "navigation-functions/LAG",
            "string-functions/RIGHT",
            "conditional-functions/CASE",
            "conditional-functions/COALESCE",
            "conditional-functions/NULLIF",
            "other-functions/UNNEST",
            "other-functions/UNPIVOT"
        ]
    },
    {
        "instance_id": "bq327",
        "db": "bigquery-public-data.world_bank_intl_debt",
        "question": "How many debt indicators for Russia have a value of 0, excluding NULL values?",
        "external_knowledge": null,
        "plan": "1. **Create a Subquery to Filter Countries with Regions:**\n   - Construct a subquery to select the country codes and regions from a summary table.\n   - Filter out rows where the region is empty to exclude aggregated countries that do not have a specific region.\n\n2. **Create a Subquery for Russia's Debt Indicators:**\n   - Construct another subquery to select the country code, country name, debt value, and indicator name from an international debt table.\n   - Filter this subquery to include only rows where the country code matches the code for Russia.\n\n3. **Join the Two Subqueries:**\n   - Perform an inner join between the two subqueries on the country code to combine the data, ensuring that only records with matching country codes from both subqueries are included.\n\n4. **Filter Out NULL Values:**\n   - Further refine the joined dataset by excluding rows where the debt value is NULL.\n\n5. **Define a Common Table Expression (CTE):**\n   - Use the results of the above steps to create a CTE that holds the filtered and joined data for Russia's debt indicators, ensuring that each combination of country name, value, and indicator name is distinct.\n\n6. **Count Debt Indicators with a Value of Zero:**\n   - Query the CTE to count the number of debt indicators where the value is exactly zero.\n   - Return this count as the final result.",
        "special_function": [
            "string-functions/FORMAT"
        ]
    },
    {
        "instance_id": "ga001",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "I want to know the preferences of customers who purchased the Google Navy Speckled Tee in December 2020. What other product was purchased with the highest total quantity alongside this item?",
        "external_knowledge": null,
        "plan": "1. Focus on the item named \"Google Navy Speckled Tee.\"\n2. Select all purchase-type events from December 2020.\n3. Extract the IDs of individuals who purchased the \"Google Navy Speckled Tee\" during these events.\n4. Calculate all items purchased by these IDs and retain the top 10 items by purchase volume.",
        "special_function": [
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "ga001_1",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "Tell me the most purchased other products and their quantities by customers who bought the Google Red Speckled Tee each month for the three months starting from November 2020.",
        "external_knowledge": null,
        "plan": "1. **Define Parameters:**\n   - Establish a parameter for the selected product, which in this case is 'Google Red Speckled Tee'.\n\n2. **Set Date Ranges:**\n   - Define the date ranges for the three consecutive months starting from November 2020.\n\n3. **Identify Purchase Events:**\n   - Extract purchase events from the dataset for the defined date ranges.\n   - Ensure to include the event period, user identifier, and items purchased.\n\n4. **Identify Buyers of Selected Product:**\n   - Identify distinct users who purchased the selected product within each period.\n   - This step filters out only those users who bought the 'Google Red Speckled Tee'.\n\n5. **Calculate Top Products Purchased by These Buyers:**\n   - For each period, calculate the total quantity of other products bought by the users identified in the previous step.\n   - Exclude the selected product from this count.\n\n6. **Rank Products by Quantity:**\n   - Rank the products for each period based on the total quantity purchased.\n   - Use a ranking function to order products in descending order of quantity.\n\n7. **Select Top Product Per Period:**\n   - Select the top-ranked product for each period.\n   - This ensures only the most purchased product (excluding the selected product) is chosen for each period.\n\n8. **Output Results:**\n   - Retrieve and display the period, product name, and quantity of the top purchased product for each period.\n   - Order the results by period to maintain chronological order.\n\nThis plan effectively breaks down the SQL query into logical steps to achieve the user\u2019s goal of identifying the most purchased other products by customers who bought a specific product within a given timeframe.",
        "special_function": [
            "numbering-functions/RANK",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "ga003",
        "db": "firebase-public-project.analytics_153293282",
        "question": "I'm trying to evaluate which board types were most effective on September 15, 2018. Can you find out the average scores for each board type from the quick play mode completions on that day?\"",
        "external_knowledge": null,
        "plan": "1. Extract all data for the \"level_complete_quickplay\" mode.\n2. Focus on the board type, grouping by user ID and event timestamp to summarize board type and corresponding scores.\n3. Calculate the average score for each board type.",
        "special_function": [
            "aggregate-functions/ANY_VALUE",
            "conditional-functions/IF",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "ga004",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "Can you figure out the average difference in pageviews between users who bought something and those who didn\u2019t in December 2020? Just label anyone who was involved in purchase events as a purchaser.",
        "external_knowledge": null,
        "plan": "1. Segment user activities into page views and purchase events for December 2020.\n2. Classify users based on whether they made any purchases.\n3. Calculate average page views for purchasers and non-purchasers.\n4. Determine the difference in average page views between these two groups.",
        "special_function": [
            "aggregate-functions/COUNTIF",
            "conditional-functions/CASE"
        ]
    },
    {
        "instance_id": "ga004_1",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "Can you give me the average page views per buyer and total page views for each day in November 2020?",
        "external_knowledge": null,
        "plan": "1. **Define a Temporary Data Set:**\n   - Create a temporary data set to collect user activity information.\n   - Parse the date format to a standard date type.\n   - Count the occurrences of 'page_view' events for each user per day.\n   - Count the occurrences of 'purchase' related events for each user per day.\n   - Filter the data for the specified date range (November 2020).\n\n2. **Aggregate User Activity:**\n   - From the temporary data set, select the date, the sum of 'page_view' counts, and the average 'page_view' counts per user who made a purchase.\n   - Ensure to include only users who have made at least one purchase-related event.\n\n3. **Compute Metrics:**\n   - For each day in November 2020:\n     - Calculate the average number of 'page_view' events per purchasing user.\n     - Calculate the total number of 'page_view' events.\n\n4. **Group and Order Results:**\n   - Group the results by date to get daily metrics.\n   - Order the results by date to maintain chronological order.",
        "special_function": [
            "aggregate-functions/COUNTIF",
            "date-functions/PARSE_DATE"
        ]
    },
    {
        "instance_id": "ga017",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "How many distinct users viewed the most frequently visited page during January 2021?",
        "external_knowledge": null,
        "plan": "1. Extract `page_view` events for January 2021 and unnest their parameters to access individual event details.\n2. Aggregate these details to identify the title of each page viewed, grouping by user and event timestamp.\n3. Count occurrences and distinct users per page, then order by the frequency of visits to each page.\n4. Select the number of distinct users for the top visited page.",
        "special_function": [
            "conditional-functions/CASE",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "ga007",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "Please find out what percentage of the page views on January 2, 2021, were for PDP type pages.",
        "external_knowledge": "ga4_page_category.md",
        "plan": "1. query the event data to retrieve all unique event names\n2. Selects events data from the Google Analytics 4 (GA4) sample e-commerce dataset for the specific date (20210102)\n3. Filter to include only events named 'page_view', which represent page views.\n4. flatten the nested event_params array and extract values for ga_session_id, ga_session_number, page_title, and page_location. This allows the analysis of individual page views within each user's session.\n5. Further processes the unnested event data to classify pages based on URL depth and specific keywords into either Product Detail Pages (PDP) or Product Listing Pages (PLP).\n6. Calculate the total proportion of PDP",
        "special_function": [
            "array-functions/ARRAY_LENGTH",
            "array-functions/ARRAY_REVERSE",
            "date-functions/DATE",
            "string-functions/CONTAINS_SUBSTR",
            "string-functions/LOWER",
            "string-functions/SPLIT",
            "conditional-functions/CASE",
            "other-functions/UNNEST",
            "other-functions/ARRAY_SUBSCRIPT"
        ]
    },
    {
        "instance_id": "ga007_1",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "I want to know all the pages visited by user 1402138.5184246691 on January 2, 2021. Please show the names of these pages and adjust the names to PDP or PLP where necessary.",
        "external_knowledge": "ga4_page_category.md",
        "plan": "1. **Create a Base Table**:\n   - Select necessary columns from the dataset.\n   - Filter the data to include only records for the specified date.\n   - Further filter to include only records for the specified user ID.\n   - Ensure that only records with the specified event type are selected.\n\n2. **Unnest Event Parameters**:\n   - Unnest the event parameters to access key-value pairs.\n   - Extract relevant values using conditional logic based on the key names.\n   - Group the data by date, timestamp, and user ID to ensure each event is uniquely identified.\n\n3. **Classify Page Names**:\n   - For each event, analyze the page location URL.\n   - Split the URL into its components for further analysis.\n   - Determine the type of page (PDP or PLP) based on predefined conditions:\n     - If the URL structure and specific keywords match certain patterns, classify the page as 'PDP'.\n     - If different patterns are matched, classify the page as 'PLP'.\n   - If none of the patterns are matched, retain the original page title.\n\n4. **Final Output**:\n   - Select all relevant fields from the unnested events.\n   - Include an additional field that contains the adjusted page title based on the classification logic.",
        "special_function": [
            "array-functions/ARRAY_LENGTH",
            "array-functions/ARRAY_REVERSE",
            "date-functions/DATE",
            "string-functions/CONTAINS_SUBSTR",
            "string-functions/LOWER",
            "string-functions/SPLIT",
            "conditional-functions/CASE",
            "other-functions/UNNEST",
            "other-functions/ARRAY_SUBSCRIPT"
        ]
    },
    {
        "instance_id": "ga018",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "I'd like to analyze the appeal of our products to users. Can you calculate the percentage of times users go from browsing the product list pages to clicking into the product detail pages at January 2nd, 2021?",
        "external_knowledge": "ga4_page_category.md",
        "plan": "1. query the event data to retrieve all unique event names\n2. Selects events data from the Google Analytics 4 (GA4) sample e-commerce dataset for the specific date (20210102)\n3. Filter to include only events named 'page_view', which represent page views.\n4. flatten the nested event_params array and extract values for ga_session_id, ga_session_number, page_title, and page_location. This allows the analysis of individual page views within each user's session.\n5. Further processes the unnested event data to classify pages based on URL depth and specific keywords into either Product Detail Pages (PDP) or Product Listing Pages (PLP).\n6. Applies window functions to the categorized data to calculate the previous and next pages for each session per user, facilitating analysis of navigation paths between pages.\n7. Filters sessions where the current page is a PLP and the next page is a PDP.\n8. Counts the number of sessions transitioning from PLP to PDP and divides this by the total views of PLP pages to calculate the conversion rate.",
        "special_function": [
            "array-functions/ARRAY_LENGTH",
            "array-functions/ARRAY_REVERSE",
            "date-functions/DATE",
            "navigation-functions/LAG",
            "navigation-functions/LEAD",
            "string-functions/CONTAINS_SUBSTR",
            "string-functions/LOWER",
            "string-functions/SPLIT",
            "conditional-functions/CASE",
            "other-functions/UNNEST",
            "other-functions/ARRAY_SUBSCRIPT"
        ]
    },
    {
        "instance_id": "ga031",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "I want to know our user conversion rate for January 2nd, 2021, calculated as the ratio of users who reached the Checkout Confirmation page to those who landed on the Home page.",
        "external_knowledge": null,
        "plan": "1. Extract and prepare event data from the Google Analytics 4 (GA4) dataset, specifically for page views on January 2, 2021.\n2. Unnest the event parameters to retrieve values for session identifiers and page identifiers, such as page title and location.\n3. Identify and count the initial visits to the Home page and the successful visits to the Checkout Confirmation page.\n4. Join the data to match sessions that start on the Home page and end at the Checkout Confirmation page.\n5. Calculate the user conversion rate for January by comparing the number of successful checkout visits to the total home page visits.",
        "special_function": [
            "date-functions/DATE",
            "conditional-functions/CASE",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "ga032",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "Can you pull up the sequence of pages our customer 1362228 visited on January 28th 2021, linking them with '>>' between each page? I want to see their navigation flow through our site. Please merge adjacent identical pages into one, and refer to the docs to convert the corresponding pages to PDP, PLP if necessary.",
        "external_knowledge": "ga4_page_category.md",
        "plan": "1. Select and filter page_view events on January 28th, 2021, specifically for user 1362228 from the GA4 dataset.\n2. Unpack the event_params array to extract details such as session ID, session number, page title, and page location.\n3. Determine page categories based on URL structure and keywords to classify pages as either Product Detail Pages (PDPs), Product Listing Pages (PLPs), or other types.\n4. Rank pages based on the event timestamp and use window functions to establish the sequence of page visits within each session.\n5. concatenate the page titles visited in sequence, separated by '>>', representing the user's navigation flow through the site.",
        "special_function": [
            "aggregate-functions/ARRAY_AGG",
            "array-functions/ARRAY",
            "array-functions/ARRAY_LENGTH",
            "array-functions/ARRAY_REVERSE",
            "array-functions/ARRAY_TO_STRING",
            "date-functions/DATE",
            "mathematical-functions/POWER",
            "navigation-functions/LAG",
            "navigation-functions/LEAD",
            "numbering-functions/DENSE_RANK",
            "string-functions/CONTAINS_SUBSTR",
            "string-functions/LOWER",
            "string-functions/SPLIT",
            "conditional-functions/CASE",
            "other-functions/UNNEST",
            "other-functions/ARRAY_SUBSCRIPT"
        ]
    },
    {
        "instance_id": "ga006",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "Provide the IDs and the average spending per session for users who were engaged in multiple purchase sessions in November 2020",
        "external_knowledge": null,
        "plan": "1. **Define Events Data**:\n   - Create a temporary table to store event data.\n   - Extract session ID and spending value from event parameters.\n   - Include all columns from the original event data.\n   - Filter the event data to include only records from November 2020.\n\n2. **Calculate Session Info**:\n   - Create another temporary table to calculate session-related metrics for each user.\n   - Count the distinct session IDs for each user to determine the number of purchase sessions.\n   - Calculate the average spending per session by dividing the total spending by the number of distinct sessions for each user.\n   - Only include events that represent a purchase and have a valid session ID.\n\n3. **Filter and Select**:\n   - Select the user IDs and their corresponding average spending per session from the session info table.\n   - Include only users who have engaged in more than one purchase session.\n\nBy following these steps, the query effectively identifies users with multiple purchase sessions in the specified timeframe and calculates their average spending per session.",
        "special_function": [
            "date-functions/DATE",
            "range-functions/RANGE",
            "string-functions/REPLACE",
            "conditional-functions/COALESCE",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "ga009",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "I want to know the average number of engaged sessions per user of December 2020.",
        "external_knowledge": null,
        "plan": "1. **Identify the Time Frame:**\n   - The query focuses on data from December 2020.\n   - Filter the dataset to include only records within this time period.\n\n2. **Engaged Sessions Calculation:**\n   - Determine the number of unique engaged sessions.\n   - An engaged session is identified by a specific event parameter indicating engagement.\n   - For each engaged session, concatenate a unique user identifier with a session identifier to ensure distinct session counts.\n\n3. **User Count Calculation:**\n   - Count the number of unique users within the specified time frame.\n   - Use a distinct user identifier to ensure each user is only counted once.\n\n4. **Calculate Averages:**\n   - Calculate the average number of engaged sessions per user.\n   - Divide the total number of engaged sessions by the total number of unique users.\n\n5. **Result Presentation:**\n   - Present the result as the average number of engaged sessions per user.",
        "special_function": [
            "conversion-functions/CAST",
            "json-functions/STRING",
            "string-functions/CONCAT",
            "timestamp-functions/STRING",
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE",
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "ga010",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "Can you give me an overview of our website traffic for December 2020? I'm particularly interested in the channel with the fourth highest number of sessions.",
        "external_knowledge": "ga4_dimensions_and_metrics.md",
        "plan": "1.First, read the document to understand how traffic is divided into 18 channel groups, primarily based on the metrics of source, medium, and campaign.\n2.Extract all visits from the database for December, each visit having a unique user ID and session ID. Retrieve the source, medium, and campaign for each visit.\n3.Based on the classification standards for channel groups in the document, write conditional statements to determine which channel each set of data belongs to, mainly using regular expressions. If the data source (source) contains any of the 4.following: 'badoo', 'facebook', 'fb', 'instagram', 'linkedin', 'pinterest', 'tiktok', 'twitter', or 'whatsapp', and the medium (medium) includes 'cp', 'ppc', or starts with 'paid', then categorize it as 'Paid Social'.\n5.Calculate the number of sessions for each channel based on the channel grouping.\n6.Select the name of the channel ranked fourth as the answer.",
        "special_function": [
            "aggregate-functions/ARRAY_AGG",
            "aggregate-functions/GROUPING",
            "string-functions/CONCAT",
            "string-functions/REGEXP_CONTAINS",
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE",
            "other-functions/SET",
            "other-functions/UNNEST",
            "other-functions/ARRAY_SUBSCRIPT"
        ]
    },
    {
        "instance_id": "ga010_1",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "Please tell me the number of sessions for each website traffic channel in December 2020.",
        "external_knowledge": "ga4_dimensions_and_metrics.md",
        "plan": "1. **Create a Preparation Step**: \n   - Define a subquery to prepare the necessary data.\n   - Select unique user identifiers.\n   - Extract session identifiers from event parameters.\n   - Aggregate source, medium, and campaign information for each session, ordering them by event timestamp to ensure correct sequence.\n\n2. **Filter for Specific Time Period**:\n   - Limit data to events occurring in December 2020 by specifying the date range.\n\n3. **Group Data by User and Session**:\n   - Group the prepared data by unique user and session identifiers to consolidate session information.\n\n4. **Classify Sessions into Channels**:\n   - Use a `CASE` statement to categorize each session into a traffic channel based on the source, medium, and campaign information.\n   - Define various conditions for channel grouping, such as direct traffic, cross-network campaigns, paid and organic shopping, search, social, video, email, affiliate, referral, audio, SMS, and mobile push notifications.\n   - Assign any sessions that do not match the predefined conditions to an \"Unassigned\" category.\n\n5. **Count Sessions per Channel**:\n   - Count the number of distinct sessions for each traffic channel by combining user and session identifiers.\n   - Group the results by the traffic channel to get the session count for each channel.\n\n6. **Return the Results**:\n   - Output the channel grouping and the corresponding session count for each channel.",
        "special_function": [
            "aggregate-functions/ARRAY_AGG",
            "aggregate-functions/GROUPING",
            "string-functions/CONCAT",
            "string-functions/REGEXP_CONTAINS",
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE",
            "other-functions/SET",
            "other-functions/UNNEST",
            "other-functions/ARRAY_SUBSCRIPT"
        ]
    },
    {
        "instance_id": "ga011",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "What is the highest number of page views for any page path in December 2020?",
        "external_knowledge": null,
        "plan": "1. **Subquery Preparation**: Start by identifying specific events and parameters from the dataset using a subquery. This subquery will extract certain key details related to page views for further analysis.\n\n2. **Extracting URL Path Components**: \n    - Use string manipulation functions to split and extract different segments of the URL path from the event parameters.\n    - Specifically, extract three different levels of the URL path:\n        - First level path segment\n        - Second level path segment\n        - Third level path segment\n    - Ensure to handle potential empty segments by checking and replacing them with `NULL` if necessary.\n\n3. **Concatenation of Path Components**: \n    - Concatenate the extracted path segments appropriately to form complete path levels.\n    - Ensure each path segment is prefixed with a '/' to maintain URL structure.\n\n4. **Filtering by Date Range**: \n    - Filter the dataset to only include records from December 2020.\n\n5. **Counting Page Views**: \n    - Group the results by the extracted path segments (pagepath levels).\n    - Count the occurrences of page view events for each group using a conditional count function.\n\n6. **Ordering and Limiting Results**: \n    - Order the grouped results by the count of page views in descending order to find the most viewed pages.\n    - Limit the final result to return only the highest count of page views.\n\n7. **Final Output**: \n    - Select and output the highest number of page views from the ordered results.",
        "special_function": [
            "aggregate-functions/COUNTIF",
            "string-functions/CONCAT",
            "string-functions/SPLIT",
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE",
            "other-functions/UNNEST",
            "other-functions/ARRAY_SUBSCRIPT"
        ]
    },
    {
        "instance_id": "ga012",
        "db": "bigquery-public-data.ga4_obfuscated_sample_ecommerce",
        "question": "Find the transaction IDs, total item quantities, and purchase revenues for the item category with the highest tax rate on November 30, 2020.",
        "external_knowledge": null,
        "plan": "1. **Identify the Top Tax Rate Category:**\n    - Create a common table expression (CTE) to calculate the tax rate for each item category.\n    - Calculate the tax rate as the ratio of the sum of tax values to the sum of purchase revenues for each category.\n    - Select the item category with the highest tax rate by ordering the results in descending order of tax rate and limiting the result to one.\n\n2. **Select Required Transaction Details:**\n    - Using the main table and the CTE, retrieve transaction details for the item category with the highest tax rate.\n    - Filter the dataset to include only purchase events.\n    - Join the main table with the CTE on the item category to ensure only transactions from the top tax rate category are considered.\n    - Group the results by transaction ID.\n\n3. **Calculate Aggregates:**\n    - For each transaction, calculate the total item quantity by summing the quantities of items.\n    - Calculate the total purchase revenue in the specified currency by summing the purchase revenue fields.\n    - Ensure the results include transaction IDs, total item quantities, and purchase revenues.\n\n4. **Output the Results:**\n    - Return the transaction ID, the aggregated total item quantity, and the aggregated purchase revenue for transactions within the top tax rate category on the specified date.",
        "special_function": [
            "other-functions/UNNEST"
        ]
    },
    {
        "instance_id": "ga019",
        "db": "firebase-public-project.analytics_153293282",
        "question": "Could you determine what percentage of users either did not uninstall our app within seven days or never uninstalled it after installing during August and September 2018?",
        "external_knowledge": null,
        "plan": "1. Extract distinct user IDs and their first open dates from events labeled as 'first_open' for the months of August and September 2020.\n2. Gather distinct user IDs and their app removal dates from events labeled 'app_remove' during the same timeframe.\n3. Join the installation data with the uninstallation data on user ID to calculate the number of days between app installation and removal.\n4. Determine the percentage of users who uninstalled the app within seven days of installation by comparing the number of users who uninstalled within this period to the total number of users who installed the app.",
        "special_function": [
            "date-functions/DATE",
            "date-functions/DATE_DIFF",
            "date-functions/FORMAT_DATE",
            "date-functions/PARSE_DATE",
            "conditional-functions/CASE"
        ]
    },
    {
        "instance_id": "ga030",
        "db": "firebase-public-project.analytics_153293282",
        "question": "Can you group users by the week they first used the app starting from July 2, 2018 and show which group has the most active users remained in the next four weeks, with each group named by the Monday date of that week? Please answer in the format of \" YYYY-MM-DD\".",
        "external_knowledge": "retention_rate.md",
        "plan": "1. **Define Date Range and Calculate Minimum Date**:\n    - Establish a specific start date and end date.\n    - Determine the minimum date by subtracting four weeks from the end date truncated to the start of the week.\n\n2. **Prepare Event Data**:\n    - Convert event dates to a standard date format.\n    - Identify whether a user is using the app for the first time on that date.\n\n3. **Extract New Users**:\n    - Create a list of users who are new, along with their first event date.\n\n4. **Calculate Days Since Start for Each User**:\n    - Determine the number of days since a user\u2019s first app use.\n    - Associate each event date with the respective user and their first event date.\n\n5. **Calculate Weeks Since Start**:\n    - Group users by the week they started using the app.\n    - Calculate the number of weeks since each user's initial use.\n\n6. **Count Retained Users by Week**:\n    - For each starting week, count the number of distinct users who are still active, grouped by the number of weeks since they started.\n\n7. **Find the Week with Most Retained Users After Four Weeks**:\n    - Identify the initial user cohorts for each week.\n    - Determine the number of users still active after four weeks for each cohort.\n    - Calculate the retention rate (users active after four weeks / initial users).\n    - Sort the results by retention rate in descending order.\n    - Select the week with the highest retention rate.\n\nThis step-by-step plan ensures that users are grouped by their initial week of usage, and the retention rates are calculated to find the week with the highest user retention after four weeks.",
        "special_function": [
            "date-functions/DATE",
            "date-functions/DATE_ADD",
            "date-functions/DATE_DIFF",
            "date-functions/DATE_TRUNC",
            "date-functions/PARSE_DATE",
            "mathematical-functions/CEIL",
            "timestamp-functions/TIMESTAMP_MICROS",
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE",
            "conditional-functions/IFNULL"
        ]
    },
    {
        "instance_id": "ga030_1",
        "db": "firebase-public-project.analytics_153293282",
        "question": "Can you group users by the week they first used the app, starting from July 9, 2018? I'd like to see the retention rate for each group over the next two weeks.",
        "external_knowledge": "retention_rate.md",
        "plan": "1. **Define Date Range and Minimum Date**:\n   - Create a CTE (Common Table Expression) to define the start date, end date, and the minimum date (which is two weeks before the end date).\n\n2. **Create Date Table**:\n   - Extract the event date and user ID from the events table.\n   - Determine if the event date is the first time the user used the app by comparing it with the user's first touch timestamp.\n   - Filter events that occurred on or after July 9, 2018, and where the event name is 'session_start'.\n\n3. **Identify New Users**:\n   - Create a list of users who are new (i.e., their first use of the app) by selecting distinct user IDs and their first event dates.\n\n4. **Calculate Days Since Start for Each User**:\n   - Calculate the number of days since each new user started using the app.\n   - This involves joining the date table with the new user list to get the event date differences for each user's subsequent events.\n\n5. **Calculate Weeks Since Start for Each User**:\n   - Group the users into weekly cohorts based on their first event date.\n   - Calculate the number of weeks since the user first used the app, where the week starts on Monday.\n\n6. **Count Retained Users**:\n   - Count the number of distinct users retained in each weekly cohort for each week since they first used the app.\n   - Ensure the counts are within the defined date range.\n\n7. **Calculate Retention Rate**:\n   - Join the retention counts for the initial week cohort with the counts for the second week (two weeks since the start).\n   - Calculate the retention rate by dividing the number of users retained in the second week by the number of users in the initial cohort.\n   - Ensure to handle cases where no users are retained by using an IFNULL function.\n\n8. **Output and Order Results**:\n   - Select the initial week cohort and the calculated retention rate.\n   - Filter to include only the initial cohorts and order the results by the week cohort for clear presentation.",
        "special_function": [
            "date-functions/DATE",
            "date-functions/DATE_ADD",
            "date-functions/DATE_DIFF",
            "date-functions/DATE_TRUNC",
            "date-functions/PARSE_DATE",
            "mathematical-functions/CEIL",
            "timestamp-functions/TIMESTAMP_MICROS",
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE",
            "conditional-functions/IFNULL"
        ]
    },
    {
        "instance_id": "ga028",
        "db": "firebase-public-project.analytics_153293282",
        "question": "Using the 7-day retention calculation method, find the number of users who first used the app in the week starting on \"2018-07-02\" and tell me the number of retained users for each week from 0 to 4 weeks.",
        "external_knowledge": "retention_rate.md",
        "plan": "1. **Define the Date Range**:\n   - Establish the start date and end date for the analysis period.\n   - Calculate the minimum date needed for the 4-week retention analysis.\n\n2. **Create Event Date Table**:\n   - Parse the event dates.\n   - Determine if a user is a new user by comparing the event date with the user's first touch timestamp.\n\n3. **Identify New Users**:\n   - Extract a list of new users who first used the app on their respective event dates.\n\n4. **Calculate Days Since First Use**:\n   - For each user, calculate the number of days since their first use.\n   - Associate each user with their event dates and the calculated days since their first use.\n\n5. **Group by Week and Calculate Retention**:\n   - Group the users by the week of their first use.\n   - Calculate the number of weeks since the user's first use.\n   - Use the ceiling function to group days into weeks, starting from 0.\n\n6. **Aggregate Retention Data**:\n   - Count the number of distinct retained users for each week since their first use.\n   - Group the data by the week cohort and the weeks since the start.\n   - Ensure that the data is limited to the defined date range and only includes up to 4 weeks.\n\n7. **Filter and Sort the Retention Data**:\n   - Filter the retention data to show only the week starting on the specified start date.\n   - Sort the data by the week cohort and the number of weeks since the start.\n\n8. **Select Final Output**:\n   - Select and display the number of retained users for each week from 0 to 4 weeks since the user's first use.",
        "special_function": [
            "date-functions/DATE",
            "date-functions/DATE_ADD",
            "date-functions/DATE_DIFF",
            "date-functions/DATE_TRUNC",
            "date-functions/PARSE_DATE",
            "mathematical-functions/CEIL",
            "timestamp-functions/TIMESTAMP_MICROS",
            "conditional-functions/CASE_EXPR",
            "conditional-functions/CASE"
        ]
    },
    {
        "instance_id": "ga020",
        "db": "firebase-public-project.analytics_153293282",
        "question": "Which quickplay event type had the lowest user retention rate during the second week after their initial engagement, for users who first engaged between August 1 and August 15, 2018?",
        "external_knowledge": "retention_rate.md",
        "plan": "1. Extract unique users who installed the app in September 2018, recording the date of first use.\n2. Collect data on users who uninstalled the app within a little over a month from installation, noting the uninstallation dates.\n3. Retrieve crash data for the same users during the specified timeframe to determine app stability issues.\n4. Combine the installation, uninstallation, and crash data into a single dataset using user ID as the key.\n5. Calculate the proportion of users who experienced a crash within a week of installation out of those who uninstalled the app within a week, providing insight into potential issues affecting user retention.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/DATE",
            "date-functions/DATE_DIFF",
            "date-functions/PARSE_DATE",
            "mathematical-functions/CEIL",
            "range-functions/RANGE",
            "conditional-functions/CASE"
        ]
    },
    {
        "instance_id": "ga020_1",
        "db": "firebase-public-project.analytics_153293282",
        "question": "What is the retention rate for users two weeks after their initial quickplay event within the period from July 2, 2018, to July 16, 2018, calculated separately for each quickplay event type?",
        "external_knowledge": "retention_rate.md",
        "plan": "1. **Define Date Range:**\n   - Establish the start and end dates for the period of interest.\n\n2. **Identify Active Dates:**\n   - Select user identifiers and their active dates (based on session start events) within the defined date range.\n\n3. **Identify Initial Quickplay Events:**\n   - For each user, determine the earliest date of specific quickplay events within the defined date range.\n\n4. **Calculate Days Since Initial Event:**\n   - For each user and each initial quickplay event type, calculate the number of days since the initial quickplay event until each subsequent active date.\n\n5. **Determine Weeks Since Initial Event:**\n   - Convert the days since the initial quickplay event into weeks and count the number of active days in each week for each user and each quickplay event type.\n\n6. **Aggregate Weekly Retention Data:**\n   - Summarize the weekly retention data by counting the active days and the number of retained users for each quickplay event type and each week.\n\n7. **Calculate Retention Rate:**\n   - Calculate the retention rate by dividing the number of retained users in each week by the maximum number of retained users in the first week for each quickplay event type.\n\n8. **Filter for Two Weeks:**\n   - Select and return the retention rates for users two weeks after their initial quickplay event for each quickplay event type.",
        "special_function": [
            "conversion-functions/CAST",
            "date-functions/DATE",
            "date-functions/DATE_DIFF",
            "date-functions/PARSE_DATE",
            "mathematical-functions/CEIL",
            "range-functions/RANGE",
            "conditional-functions/CASE"
        ]
    },
    {
        "instance_id": "ga025",
        "db": "firebase-public-project.analytics_153293282",
        "question": "For all users who first opened the app in September 2018 and then uninstalled within seven days, I want to know what percentage of them experienced an app crash.",
        "external_knowledge": null,
        "plan": "1. Extract users who installed the app in September 2018.\n2. Extract users who uninstalled the app between September 1 and October 7, 2018.\n3. Extract users who experienced app crashes between September 1 and October 7, 2018.\n4. Combine these datasets to analyze the relationship between crashes and uninstallations.\n5. Calculate the percentage of users who uninstalled within a week and experienced crashes to determine the impact of app crashes on user retention.",
        "special_function": [
            "date-functions/DATE",
            "date-functions/DATE_DIFF",
            "date-functions/FORMAT_DATE",
            "date-functions/PARSE_DATE",
            "conditional-functions/CASE",
            "other-functions/UNNEST"
        ]
    }
]